<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <title>언제 노을이 예쁠까? v1.2.0</title>
    <style>
        :root {
            --bg: #0e1016;
            --card: #161b23;
            --ink: #e9eef6;
            --muted: #a6b0c4;
            --accent: #3a7afe;
        }

        html, body {
            background: var(--bg);
            color: var(--ink);
            font-family: system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,Arial,sans-serif;
            margin: 0;
            padding: 0
        }

        header {
            padding: 16px 14px;
            border-bottom: 1px solid #232735;
            background: linear-gradient(180deg,rgba(58,122,254,0.08),transparent)
        }

        h1 {
            font-size: 19px;
            margin: 0 0 4px
        }

        .sub {
            color: var(--muted);
            font-size: 12.5px;
            margin: 0
        }

        .wrap {
            max-width: 1100px;
            margin: 0 auto;
            padding: 12px
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px
        }

        .card {
            background: var(--card);
            border: 1px solid #242a36;
            border-radius: 12px;
            overflow: hidden
        }

            .card header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                background: transparent;
                border: none;
                padding: 12px 14px
            }

        .loc {
            display: flex;
            gap: 8px;
            align-items: center
        }

        .badge {
            font-size: 11.5px;
            border: 1px solid #2b3140;
            border-radius: 999px;
            padding: 3px 8px;
            color: var(--muted)
        }

        .src {
            color: var(--muted);
            font-size: 12.5px;
            margin-left: 6px
        }

        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap
        }

        button {
            background: var(--accent);
            color: white;
            border: 0;
            border-radius: 10px;
            padding: 8px 10px;
            font-size: 12.5px;
            font-weight: 700;
            cursor: pointer
        }

        .note {
            font-size: 11.5px;
            color: var(--muted);
            padding: 10px 14px;
            line-height: 1.6
        }

        .err {
            color: #ffb1b1
        }

        table {
            width: 100%;
            border-collapse: collapse
        }

        th, td {
            padding: 8px 10px;
            border-top: 1px solid #232735;
            font-size: 12.5px;
            text-align: center;
            white-space: nowrap;
            vertical-align: middle
        }

        th {
            color: #cbd3e1;
            background: #192131;
            position: sticky;
            top: 0;
            z-index: 1
        }

            td:first-child, th:first-child {
                text-align: left
            }

        .score {
            font-weight: 700;
            color: var(--accent);
            font-size: 1.1em;
        }

        .pill {
            padding: 2px 7px;
            border-radius: 999px;
            font-weight: 700;
            font-size: 11px;
            display: inline-block
        }

        .great {
            background: rgba(30,142,62,0.15);
            color: #8de6a6;
            border: 1px solid rgba(30,142,62,0.35)
        }

        .good {
            background: rgba(58,122,254,0.12);
            color: #a8c3ff;
            border: 1px solid rgba(58,122,254,0.35)
        }

        .fair {
            background: rgba(176,127,0,0.18);
            color: #ffd27a;
            border: 1px solid rgba(176,127,0,0.35)
        }

        .poor {
            background: rgba(176,59,59,0.18);
            color: #ffb1b1;
            border: 1px solid rgba(176,59,59,0,35)
        }

        .sw {
            white-space: normal;
            line-height: 1.3
        }

        .nowrap {
            white-space: nowrap
        }

        .skeleton {
            padding: 16px;
            color: #9aa3b6
        }

        th.info {
            cursor: pointer;
            position: relative
        }

            th.info::after {
                content: "ⓘ";
                font-size: 10px;
                margin-left: 6px;
                color: #9bb7ff
            }

        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            backdrop-filter: blur(2px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 50
        }

            .overlay.show {
                display: flex
            }

        .sheet {
            background: var(--card);
            border: 1px solid #242a36;
            border-radius: 12px;
            width: calc(100% - 24px);
            max-width: 560px;
            max-height: 80vh;
            overflow: auto;
            padding: 12px 14px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4)
        }

            .sheet h3 {
                margin: 4px 0 8px;
                font-size: 14px;
                color: var(--accent)
            }

            .sheet h4 {
                font-size: 12px;
                color: var(--muted);
                margin: 12px 0 4px;
                border-bottom: 1px solid #242a36;
                padding-bottom: 4px;
            }

            .sheet .mini {
                font-size: 12px;
                line-height: 1.55;
                color: #c8d0e0
            }

            .sheet .close {
                position: sticky;
                top: 0;
                float: right;
                margin: -6px -4px 0 0;
                background: transparent;
                border: 1px solid #2b3140;
                color: #cfd7e6;
                border-radius: 8px;
                padding: 4px 8px
            }

            .sheet p {
                margin: 0 0 10px;
            }

            .sheet strong {
                color: var(--ink);
                font-weight: 600;
            }

            .sheet code {
                background: #0c0f15;
                border: 1px solid #2b3140;
                border-radius: 4px;
                padding: 1px 4px;
                font-size: 0.9em;
                color: #ffd27a;
            }

        @media(max-width:430px) {
            h1 {
                font-size: 18px
            }

            th, td {
                font-size: 12px;
                padding: 7px 8px
            }

            .wrap {
                padding: 10px
            }

            .controls button {
                font-size: 12px;
                padding: 7px 9px
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>언제 노을이 예쁠까? v1.2.0</h1>
        <p class="sub" id="subtitle"><b>빛길 가림에 대한 부채꼴 샘플링 + 후면 청천 반영</b></p>
    </header>

    <div class="wrap">
        <div class="controls" style="margin-bottom:10px">
            <button id="refresh">지금 예보 새로고침</button>
        </div>

        <div class="grid" id="panels">
            <div class="card skeleton">예보 로딩 중…</div>
        </div>

        <div class="card" id="sunset-bible" style="margin-top:12px">
        </div>
    </div>

    <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="sheet">
            <button class="close" id="ov-close">닫기</button>
            <h3 id="ov-title"></h3>
            <div id="ov-body" class="mini"></div>
        </div>
    </div>

    <script>
        // ==================================================================
        // CONFIGURATION & CONSTANTS
        // ==================================================================
        const FORECAST_DAYS = 5;
        const WEST_OFFSET_LON = -0.7;

        const LOCATIONS = [
            { name: "하늘공원", lat: 37.56764, lon: 126.88571 },
            { name: "선유교", lat: 37.54361, lon: 126.90000 }
        ];

        const WEDGE_CONFIG = {
            SPREAD_DEG: 24, // SunAz ±12°
            RAYS: 3,
            RADII_KM: [30, 60, 90],
            DISTANCE_WEIGHTS: { 30: 0.2, 60: 0.3, 90: 0.5 },
            CONCURRENCY: 4
        };

        // ==================================================================
        // DOM & UI HANDLERS
        // ==================================================================
        const panels = document.getElementById('panels');
        const subtitle = document.getElementById('subtitle');
        const overlay = document.getElementById('overlay');
        const ovTitle = document.getElementById('ov-title');
        const ovBody = document.getElementById('ov-body');
        const ovClose = document.getElementById('ov-close');
        const bibleContainer = document.getElementById('sunset-bible');

        function showOverlay(title, html) { ovTitle.innerHTML = title; ovBody.innerHTML = html; overlay.classList.add('show'); }
        function hideOverlay() { overlay.classList.remove('show'); }
        overlay.addEventListener('click', (e) => { if (e.target === overlay) hideOverlay(); });
        ovClose.addEventListener('click', hideOverlay);
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hideOverlay(); });

        const METRIC_INFO = {
            "점수": { title: "최종 점수", body: `<p>노을의 종합적인 기대 점수입니다.</p><p><strong>계산법:</strong><br><code>최종 점수 = Gate 점수 × Quality 점수</code></p>` },
            "Gate": { title: "Gate 점수", body: `<p>노을 관측을 방해하는 '장애물'이 없는지를 평가하는 0과 1 사이의 종합 지수입니다.</p><p><strong>계산법:</strong><br><code>Gate = G.구름 × G.강수 × G.대기 × G.시정</code></p>` },
            "Quality": { title: "Quality 점수", body: `<p>관측이 가능하다는 전제 하에, 노을이 얼마나 아름다울지를 평가하는 100점 만점의 점수입니다.</p><p><strong>계산법:</strong><br><code>Quality = Q.구름 + 광원 개방도 + Q.대기 + Q.습도 + 후면 청천</code></p>` },
            "상층운(%)": { title: "상층운 (High Cloud)", body: `<h4>무엇인가? (What it is)</h4><p>하늘 높은 곳(6km 이상)에 위치한 구름의 비율(%)입니다. 주로 새털구름(권운) 형태이며, 노을빛을 반사하는 <strong>가장 이상적인 '캔버스'</strong> 역할을 합니다.</p><h4>왜 중요한가? (Why it matters)</h4><p>상층운이 적절히 분포하면 햇빛이 넓게 퍼지며 다채롭고 풍부한 색감의 노을이 만들어집니다. 너무 없으면 하늘이 밋밋하고, 너무 많으면 오히려 빛을 가릴 수 있어 '최적의 양'을 찾는 것이 중요합니다.</p><h4>점수 계산법 (How it's scored)</h4><p>45%일 때 가장 높은 점수를 받는 <strong>가우시안(정규분포) 함수</strong>를 사용합니다.<br><code>Quality 기여도 = 25 × exp( -(h-45)² / (2×20²) )</code></p>` },
            "중층운(%)": { title: "중층운 (Mid Cloud)", body: `<h4>무엇인가? (What it is)</h4><p>중간 높이(2~6km)에 위치한 구름의 비율(%)입니다.</p><h4>왜 중요한가? (Why it matters)</h4><p>상층운과 함께 노을을 다채롭고 입체적으로 만듭니다.</p><h4>점수 계산법 (How it's scored)</h4><p>35%일 때 가장 높은 점수를 받는 <strong>가우시안 함수</strong>를 사용합니다.<br><code>Quality 기여도 = 15 × exp( -(m-35)² / (2×15²) )</code></p>` },
            "저층운(%)": { title: "저층운 (Low Cloud)", body: `<h4>무엇인가? (What it is)</h4><p>낮은 고도(2km 미만)에 위치한 구름의 비율(%)입니다.</p><h4>왜 중요한가? (Why it matters)</h4><p>해가 지는 경로의 빛을 직접적으로 차단하는 '장애물'입니다. 양이 많을수록 노을이 생길 가능성이 급격히 낮아집니다.</p><h4>점수 계산법 (How it's scored)</h4><p>60%를 초과하면 Gate 점수를 급격히 하락시켜 최종 점수를 0에 가깝게 만듭니다.<br><code>Gate 기여도 = 1 / (1 + exp(-0.25 * (60 - l)))</code></p>` },
            "광원 개방도(%)": { title: "광원 개방도 (Light Source Openness)", body: `<h4>무엇인가? (What it is)</h4><p>해가 지는 방향의 '빛길'이 열려있는 정도를 평가합니다.</p><h4>왜 중요한가? (Why it matters)</h4><p>서쪽 하늘의 중/저층운은 햇빛이 우리 머리 위 구름(캔버스)에 도달하는 것을 막는 가장 큰 장애물입니다. 이 점수가 높을수록 '빛길'이 깨끗함을 의미합니다.</p><h4>점수 계산법 (How it's scored)</h4><p>일몰 방향 부채꼴 영역의 가중 평균 차폐율(WSOI)을 계산하여 점수에 반영합니다 (최대 +30점).</p>` },
            "PM2.5(µg/m³)": { title: "초미세먼지 (PM2.5)", body: `<h4>무엇인가? (What it is)</h4><p>대기 중 초미세먼지 농도(μg/m³)입니다.</p><h4>왜 중요한가? (Why it matters)</h4><p>낮을수록 노을의 채도가 선명해지고, 색이 깨끗하고 다채롭게 표현됩니다. 농도가 높으면 빛이 산란되어 뿌옇고 붉은색만 남게 됩니다.</p><h4>점수 계산법 (How it's scored)</h4><p>농도가 낮을수록 Quality 점수가 높아지며, '매우 나쁨' 기준인 75를 초과하면 Gate 점수가 급락합니다.</p>` },
            "시정(km)": { title: "가시거리 (Visibility)", body: `<h4>무엇인가? (What it is)</h4><p>수평 가시거리(km)입니다.</p><h4>왜 중요한가? (Why it matters)</h4><p>대기의 탁도를 나타내는 직관적인 지표입니다. 시정이 길수록 대기가 깨끗하여 노을빛이 손실 없이 선명하게 전달됩니다.</p><h4>점수 계산법 (How it's scored)</h4><p>길수록 Quality 점수가 높아지며, 2km 미만으로 매우 낮으면 Gate 점수가 급락합니다.</p>` },
            "습도(%)": { title: "습도 (Humidity)", body: `<h4>무엇인가? (What it is)</h4><p>기온과 이슬점의 차이(T-Td)로 계산된 상대 습도입니다.</p><h4>왜 중요한가? (Why it matters)</h4><p>적절한 습도는 빛의 산란에 영향을 주어 노을 색감을 풍부하게 만듭니다.</p><h4>점수 계산법 (How it's scored)</h4><p>상대습도가 40-70% 사이(T-Td 5-10°C)일 때 Quality 점수가 가장 높아집니다.</p>` },
            "후면 청천": { title: "후면 청천 (Clearing)", body: `<h4>무엇인가? (What it is)</h4><p>비구름이 지나간 직후 서쪽부터 하늘이 개이는 현상을 감지하면 보너스 점수를 부여합니다.</p><h4>왜 중요한가? (Why it matters)</h4><p>전선이 통과한 후의 노을은 대기가 매우 깨끗하고, 극적인 구름 모양이 연출되어 역대급 노을이 될 확률이 높습니다.</p><h4>점수 계산법 (How it's scored)</h4><p>일몰 직전 저층운이 급격히 감소하는 패턴이 감지될 때 Quality 점수에 <strong>+10점</strong> 보너스가 부여됩니다.</p>` }
        };

        // ==================================================================
        // MATH & TIME UTILITIES
        // ==================================================================
        function fmt(n, digits = 0, fallback = "—") { return (n == null || isNaN(n)) ? fallback : Number(n).toFixed(digits); }

        function avgOverWindow(times, values, start, end) {
            if (!values) return null;
            let sum = 0, count = 0;
            for (let i = 0; i < times.length; i++) {
                const t = new Date(times[i]).getTime();
                if (t >= start.getTime() && t <= end.getTime()) {
                    if (values[i] !== null) {
                        sum += values[i];
                        count++;
                    }
                }
            }
            return count > 0 ? sum / count : null;
        }

        function computeClearing(hourlyData, sunsetISO) {
            const sunsetTime = new Date(sunsetISO);
            const prevStart = new Date(sunsetTime.getTime() - 4 * 3600 * 1000);
            const prevEnd = new Date(sunsetTime.getTime() - 2 * 3600 * 1000);
            const nowStart = new Date(sunsetTime.getTime() - 30 * 60000);
            const nowEnd = new Date(sunsetTime.getTime() + 30 * 60000);

            const lowPrev = avgOverWindow(hourlyData.time, hourlyData.cloudcover_low, prevStart, prevEnd);
            const lowNow = avgOverWindow(hourlyData.time, hourlyData.cloudcover_low, nowStart, nowEnd);
            const midNow = avgOverWindow(hourlyData.time, hourlyData.cloudcover_mid, nowStart, nowEnd);
            const highNow = avgOverWindow(hourlyData.time, hourlyData.cloudcover_high, nowStart, nowEnd);

            if ([lowPrev, lowNow, midNow, highNow].some(v => v === null)) return false;

            const drop = lowPrev - lowNow;
            const midHighNow = Math.max(midNow, highNow);

            return (drop >= 20) && (midHighNow >= 20);
        }

        function getSunAzimuth(date, lat, lon) {
            const toRad = Math.PI / 180;
            const toDeg = 180 / Math.PI;
            const dayN = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24));
            const B = toRad * (360 / 365) * (dayN - 81);
            const eot = 9.87 * Math.sin(2 * B) - 7.53 * Math.cos(B) - 1.5 * Math.sin(B);
            const solarTime = (date.getHours() * 60 + date.getMinutes() + date.getSeconds() / 60 + 4 * lon + eot) / 60;
            const HRA = toRad * 15 * (solarTime - 12);
            const declination = toRad * -23.45 * Math.cos(toRad * (360 / 365) * (dayN + 10));
            lat = toRad * lat;
            const sin_el = Math.sin(declination) * Math.sin(lat) + Math.cos(declination) * Math.cos(lat) * Math.cos(HRA);
            const cos_az = (Math.sin(declination) * Math.cos(lat) - Math.cos(declination) * Math.sin(lat) * Math.cos(HRA)) / Math.cos(Math.asin(sin_el));
            let azimuth = toDeg * Math.acos(cos_az);
            return (solarTime < 12) ? azimuth : 360 - azimuth;
        }

        function destPoint(lat, lon, distanceKm, bearingDeg) {
            const R = 6371;
            const toRad = Math.PI / 180, toDeg = 180 / Math.PI;
            const d = distanceKm / R;
            const bearing = bearingDeg * toRad;
            const lat1 = lat * toRad, lon1 = lon * toRad;
            const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) * Math.sin(d) * Math.cos(bearing));
            const lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(d) * Math.cos(lat1), Math.cos(d) - Math.sin(lat1) * Math.sin(lat2));
            return { lat: lat2 * toDeg, lon: (lon2 * toDeg + 540) % 360 - 180 };
        }

        // ==================================================================
        // SCORE CALCULATION ENGINE
        // ==================================================================
        function calculateNoeulIndex(p) {
            const Q_Cloud_h = 25 * Math.exp(-Math.pow(p.h - 45, 2) / (2 * Math.pow(20, 2)));
            const Q_Cloud_m = 15 * Math.exp(-Math.pow(p.m - 35, 2) / (2 * Math.pow(15, 2)));
            const Q_Cloud = Q_Cloud_h + Q_Cloud_m;

            const westCloudFactor = 1 - 1 / (1 + Math.exp(-0.12 * (60 - p.wc)));
            const Q_West = 30 * westCloudFactor;

            const pmFactor = Math.max(0, 1 - p.pm25 / 55);
            const visFactor = Math.min(1, p.vis / 10);
            const Q_Air = 10 * pmFactor + 5 * visFactor;

            const ttd = p.temp - p.dew;
            const Q_Humid = 15 * Math.exp(-Math.pow(ttd - 8, 2) / (2 * Math.pow(5, 2)));

            const Q_Bonus = p.clearing ? 10 : 0;

            const qualityScore = Q_Cloud + Q_West + Q_Air + Q_Humid + Q_Bonus;

            const G_Cloud = 1 / (1 + Math.exp(-0.25 * (60 - p.l)));
            const G_Precip = Math.exp(-0.03 * p.pop) * Math.exp(-1.2 * p.pcp);
            const G_PM = 1 / (1 + Math.exp(-0.15 * (75 - p.pm25)));
            const G_Vis = 1 / (1 + Math.exp(-1.2 * (p.vis - 2)));
            const gateScore = G_Cloud * G_Precip * G_PM * G_Vis;

            const finalScore = gateScore * qualityScore;

            let verdict, cls;
            if (finalScore >= 70) { verdict = "역대급"; cls = "great"; }
            else if (finalScore >= 50) { verdict = "추천"; cls = "good"; }
            else if (finalScore >= 30) { verdict = "보통"; cls = "fair"; }
            else { verdict = "쉼"; cls = "poor"; }

            return {
                finalScore, gateScore, qualityScore, verdict, cls, Q_West, qBonus: Q_Bonus,
                scores: { Q_Cloud_h, Q_Cloud_m, Q_West, Q_Air, Q_Humid }
            };
        }

        // ==================================================================
        // UI RENDERING
        // ==================================================================
        function buildCard(loc, allDayData) {
            const el = document.createElement('div');
            el.className = 'card';
            el.innerHTML = `
        <header>
          <div class="loc"><div class="badge">좌표 ${loc.lat.toFixed(5)}, ${loc.lon.toFixed(5)}</div> <span class="src">${loc.name}</span></div>
        </header>
        <div style="overflow:auto">
          <table>
            <thead>
              <tr>
                <th>날짜</th>
                <th>판정</th>
                <th class="info" data-key="점수">점수</th>
                <th>촬영 시간대</th>
                <th class="info" data-key="Gate">Gate</th>
                <th class="info" data-key="Quality">Quality</th>
                <th class="info" data-key="상층운(%)">상층운(%)</th>
                <th class="info" data-key="중층운(%)">중층운(%)</th>
                <th class="info" data-key="저층운(%)">저층운(%)</th>
                <th class="info" data-key="광원 개방도(%)">광원 개방도(%)</th>
                <th class="info" data-key="PM2.5(µg/m³)">PM2.5(µg/m³)</th>
                <th class="info" data-key="시정(km)">시정(km)</th>
                <th class="info" data-key="습도(%)">습도(%)</th>
                <th class="info" data-key="후면 청천">후면 청천</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      `;
            panels.appendChild(el);
            const tbody = el.querySelector('tbody');

            allDayData.forEach(data => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
            <td>${data.date}</td>
            <td><span class="pill ${data.cls}">${data.verdict}</span></td>
            <td class="score">${fmt(data.finalScore, 0)}</td>
            <td class="sw">${data.shooting_window_html}</td>
            <td>${fmt(data.gateScore, 2)}</td>
            <td>${fmt(data.qualityScore, 0)}</td>
            <td>${fmt(data.params.h, 0)}</td>
            <td>${fmt(data.params.m, 0)}</td>
            <td>${fmt(data.params.l, 0)}</td>
            <td>${fmt(data.Q_West, 0)}</td>
            <td>${fmt(data.params.pm25, 1)}</td>
            <td>${fmt(data.params.vis, 1)}</td>
            <td>${fmt(100 - (data.params.temp - data.params.dew) * 5, 0)}</td>
            <td>${data.qBonus > 0 ? '✔️' : '—'}</td>
          `;
                tbody.appendChild(tr);
                tr.dataset.metrics = JSON.stringify(data);
            });
            attachHeaderTooltips(el);
        }

        function renderAllFromData(allRowsData) {
            panels.innerHTML = '';
            const grouped = allRowsData.reduce((acc, row) => {
                if (!acc[row.location]) acc[row.location] = [];
                acc[row.location].push(row);
                return acc;
            }, {});

            for (const loc of LOCATIONS) {
                if (grouped[loc.name]) {
                    buildCard(loc, grouped[loc.name]);
                }
            }
        }

        function attachHeaderTooltips(cardEl) {
            cardEl.querySelectorAll('th.info').forEach(header => {
                header.addEventListener('click', (e) => {
                    const table = e.target.closest('table');
                    const firstRow = table.querySelector('tbody tr');
                    if (!firstRow) return;

                    const key = header.getAttribute('data-key');
                    const data = JSON.parse(firstRow.dataset.metrics);
                    if (METRIC_INFO[key]) {
                        showOverlay(METRIC_INFO[key].title, generateModalContent(key, data));
                    }
                });
            });
        }

        function generateModalContent(key, data) {
            const p = data.params;
            let liveCalc = '';

            switch (key) {
                case '상층운(%)':
                    liveCalc = `<h4>현재 값 대입 예시:</h4>
                <p>오늘 ${data.location}의 상층운 평균(h)은 <strong>${fmt(p.h, 1)}%</strong> 입니다.<br>
                <code>점수 = 25 × exp( -(${fmt(p.h, 1)}-45)² / 800 )</code><br>
                <code>= <strong>${fmt(data.scores.Q_Cloud_h, 1)}점</strong></code></p>`;
                    break;
                case '중층운(%)':
                    liveCalc = `<h4>현재 값 대입 예시:</h4>
                <p>오늘 ${data.location}의 중층운 평균(m)은 <strong>${fmt(p.m, 1)}%</strong> 입니다.<br>
                <code>점수 = 15 × exp( -(${fmt(p.m, 1)}-35)² / 450 )</code><br>
                <code>= <strong>${fmt(data.scores.Q_Cloud_m, 1)}점</strong></code></p>`;
                    break;
                case '광원 개방도(%)':
                    liveCalc = `<h4>현재 값 대입 예시:</h4>
                <p>오늘 ${data.location}의 서쪽 하늘 차폐율(WSOI)은 <strong>${fmt(p.wc, 1)}%</strong> 입니다.<br>
                <code>점수 = 30 × (1 - 1 / (1 + exp(-0.12 * (60 - ${fmt(p.wc, 1)}))))</code><br>
                <code>= <strong>${fmt(data.Q_West, 1)}점</strong></code></p>`;
                    break;
            }

            return `${METRIC_INFO[key].body}${liveCalc}`;
        }

        // ==================================================================
        // DATA FETCHING & PROCESSING
        // ==================================================================
        async function pMap(items, limit, mapper) {
            const results = [];
            const executing = [];
            for (const item of items) {
                const p = Promise.resolve().then(() => mapper(item));
                results.push(p);
                if (limit <= items.length) {
                    const e = p.then(() => executing.splice(executing.indexOf(e), 1));
                    executing.push(e);
                    if (executing.length >= limit) {
                        await Promise.race(executing);
                    }
                }
            }
            return Promise.all(results);
        }

        async function fetchForecastData() {
            let allData = [];
            const hourlyParams = "cloudcover_high,cloudcover_mid,cloudcover_low,visibility,temperature_2m,dewpoint_2m,precipitation_probability,precipitation";
            const dailyParams = "sunset";

            for (const loc of LOCATIONS) {
                const omUrl = `https://api.open-meteo.com/v1/forecast?latitude=${loc.lat}&longitude=${loc.lon}&hourly=${hourlyParams}&daily=${dailyParams}&timezone=Asia/Seoul&forecast_days=${FORECAST_DAYS}`;
                const omAqUrl = `https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${loc.lat}&longitude=${loc.lon}&hourly=pm2_5&timezone=Asia/Seoul&forecast_days=${FORECAST_DAYS}`;

                const [om, omAq] = await Promise.all([
                    fetch(omUrl).then(r => r.json()),
                    fetch(omAqUrl).then(r => r.json()),
                ]);

                if (om.error) throw new Error(`Open-Meteo Error: ${om.reason}`);
                if (omAq.error) throw new Error(`Air Quality API Error: ${omAq.reason}`);

                for (let i = 0; i < om.daily.time.length; i++) {
                    const sunsetISO = om.daily.sunset[i];
                    const sunsetTime = new Date(sunsetISO);

                    const winStart = new Date(sunsetTime.getTime() - 60 * 60000);
                    const winEnd = new Date(sunsetTime.getTime() + 40 * 60000);

                    const sunAzimuth = getSunAzimuth(sunsetTime, loc.lat, loc.lon);

                    const wedgePoints = [];
                    WEDGE_CONFIG.RADII_KM.forEach(R => {
                        for (let j = 0; j < WEDGE_CONFIG.RAYS; j++) {
                            const angle = sunAzimuth - (WEDGE_CONFIG.SPREAD_DEG / 2) + (j / (WEDGE_CONFIG.RAYS - 1 || 1)) * WEDGE_CONFIG.SPREAD_DEG;
                            wedgePoints.push({ R, ...destPoint(loc.lat, loc.lon, R, angle) });
                        }
                    });

                    const wedgeResults = await pMap(wedgePoints, WEDGE_CONFIG.CONCURRENCY, async (point) => {
                        const url = `https://api.open-meteo.com/v1/forecast?latitude=${point.lat}&longitude=${point.lon}&hourly=cloudcover_mid,cloudcover_low&timezone=Asia/Seoul&forecast_days=${FORECAST_DAYS}`;
                        try {
                            const data = await fetch(url).then(r => r.json());
                            const avgM = avgOverWindow(data.hourly.time, data.hourly.cloudcover_mid, winStart, winEnd);
                            const avgL = avgOverWindow(data.hourly.time, data.hourly.cloudcover_low, winStart, winEnd);
                            return { R: point.R, m: avgM, l: avgL };
                        } catch {
                            return { R: point.R, m: null, l: null };
                        }
                    });

                    let totalWeightedOcclusion = 0, totalWeight = 0;
                    wedgeResults.forEach(r => {
                        if (r.m !== null && r.l !== null) {
                            const occlusion = (r.l * 0.7) + (r.m * 0.3);
                            const weight = WEDGE_CONFIG.DISTANCE_WEIGHTS[r.R];
                            totalWeightedOcclusion += occlusion * weight;
                            totalWeight += weight;
                        }
                    });
                    const WSOI = totalWeight > 0 ? totalWeightedOcclusion / totalWeight : 50;

                    const hourly = om.hourly;
                    const params = {
                        h: avgOverWindow(hourly.time, hourly.cloudcover_high, winStart, winEnd),
                        m: avgOverWindow(hourly.time, hourly.cloudcover_mid, winStart, winEnd),
                        l: avgOverWindow(hourly.time, hourly.cloudcover_low, winStart, winEnd),
                        pop: avgOverWindow(hourly.time, hourly.precipitation_probability, winStart, winEnd),
                        pcp: avgOverWindow(hourly.time, hourly.precipitation, winStart, winEnd),
                        pm25: avgOverWindow(omAq.hourly.time, omAq.hourly.pm2_5, winStart, winEnd),
                        vis: (avgOverWindow(hourly.time, hourly.visibility, winStart, winEnd) || 0) / 1000,
                        temp: avgOverWindow(hourly.time, hourly.temperature_2m, winStart, winEnd),
                        dew: avgOverWindow(hourly.time, hourly.dewpoint_2m, winStart, winEnd),
                        wc: WSOI,
                        clearing: computeClearing(om.hourly, sunsetISO)
                    };

                    Object.keys(params).forEach(key => { if (params[key] === null) params[key] = 0; });

                    const result = calculateNoeulIndex(params);

                    const shootHtml = `<span class="nowrap">${winStart.toLocaleTimeString('sv-SE', { timeZone: 'Asia/Seoul', hour: '2-digit', minute: '2-digit' })}</span><br><span class="nowrap">~ ${winEnd.toLocaleTimeString('sv-SE', { timeZone: 'Asia/Seoul', hour: '2-digit', minute: '2-digit' })}</span>`;
                    const dateFmt = `${sunsetTime.getMonth() + 1}.${sunsetTime.getDate()} (${'일월화수목금토'[sunsetTime.getDay()]})`;

                    allData.push({ location: loc.name, date: dateFmt, shooting_window_html: shootHtml, params, ...result });
                }
            }
            return allData;
        }

        // ==================================================================
        // MAIN CONTROLLER
        // ==================================================================
        async function main() {
            subtitle.textContent = "최신 예보를 API에서 가져오는 중...";
            panels.innerHTML = '<div class="card skeleton">예보 로딩 중…</div>';

            try {
                const data = await fetchForecastData();
                renderAllFromData(data);
                subtitle.textContent = `최신 예보 (업데이트: ${new Date().toLocaleTimeString('ko-KR')})`;
            } catch (err) {
                console.error(err);
                panels.innerHTML = `<div class="card"><div class="note err"><b>데이터 로드 중 오류</b>: ${err.message}.</div></div>`;
                subtitle.textContent = "오류 발생";
            }
        }

        // ==================================================================
        // INITIALIZATION
        // ==================================================================
        document.getElementById('refresh').addEventListener('click', main);

        function initializeBible() {
            bibleContainer.innerHTML = `<div class="note">
        <h3>The Sunset Bible: 노을 예보 모델 해설서 v1.2.0</h3>
        <p>이 모델은 노을의 품질을 <strong>'관측 가능성(Gate)'</strong>과 <strong>'미학적 품질(Quality)'</strong>이라는 두 가지 큰 축으로 나누어 평가합니다. 최종 점수는 두 점수를 곱하여 산출되며, 이는 아무리 아름다운 노을(높은 Quality)이라도 관측이 불가능한 환경(낮은 Gate)에서는 볼 수 없다는 현실을 반영합니다.</p>
        <h4>Part 1: The Gate (관측 가능성)</h4>
        <p>Gate 점수는 0과 1 사이의 값으로, 1에 가까울수록 관측에 방해 요소가 없음을 의미합니다. 4개의 하위 지표가 모두 곱해지므로, 하나라도 나쁘면 전체 점수가 급격히 하락합니다.</p>
        <ul>
            <li><strong>G.구름 (저층운 차폐)</strong>: 저층운(l)은 햇빛을 가리는 가장 큰 장애물입니다. 60%를 임계점으로 점수가 급락하는 Sigmoid 함수를 사용합니다.<br><code>G_Cloud = 1 / (1 + exp(-0.25 * (60 - l)))</code></li>
            <li><strong>G.강수 (Precipitation)</strong>: 강수확률(pop)과 강수량(pcp)은 관측을 불가능하게 만듭니다. 지수 감소 함수를 사용하여 확률이나 양이 조금만 있어도 점수가 기하급수적으로 감소합니다.<br><code>G_Precip = exp(-0.03 * pop) * exp(-1.2 * pcp)</code></li>
            <li><strong>G.대기 (PM2.5)</strong>: 초미세먼지(pm25)가 '매우 나쁨' 기준인 75µg/m³를 초과하면 하늘이 뿌옇게 되어 노을을 볼 수 없습니다.<br><code>G_PM = 1 / (1 + exp(-0.15 * (75 - pm25)))</code></li>
            <li><strong>G.시정 (Visibility)</strong>: 가시거리(vis)가 2km 미만인 짙은 안개나 박무는 노을 관측을 불가능하게 합니다.<br><code>G_Vis = 1 / (1 + exp(-1.2 * (vis - 2)))</code></li>
        </ul>
        <h4>Part 2: The Quality (미학적 품질)</h4>
        <p>Quality 점수는 100점 만점을 기준으로 가감되며, 노을의 아름다움을 결정하는 요소들의 합으로 계산됩니다.</p>
        <ul>
            <li><strong>Q.구름 (최대 40점)</strong>: 노을의 캔버스 역할을 하는 고층운(h)과 중층운(m)을 평가합니다. 각 구름의 '최적량'이 존재하며, 너무 많거나 적으면 감점됩니다.<br><code>Score_h = 25 * exp(-(h - 45)² / 800)</code><br><code>Score_m = 15 * exp(-(m - 35)² / 450)</code></li>
            <li><strong>Q.광원 개방도 (최대 30점)</strong>: 서쪽 하늘의 '빛길'이 얼마나 열려있는지를 서쪽 좌표의 가중 평균 차폐율(wc)로 평가합니다.<br><code>Score_west = 30 * (1 - 1 / (1 + exp(-0.12 * (60 - wc))))</code></li>
            <li><strong>Q.대기 (최대 15점)</strong>: 깨끗한 대기가 노을의 채도를 높입니다. 미세먼지(pm25)와 가시거리(vis)를 조합하여 평가합니다.<br><code>Score_air = (10 * max(0, 1 - pm25 / 55)) + (5 * min(1, vis / 10))</code></li>
            <li><strong>Q.습도 (최대 15점)</strong>: 적절한 습도는 색감을 풍부하게 합니다. 기온-이슬점 차이(ttd)가 8°C 근처일 때 가장 높은 점수를 받습니다.<br><code>Score_humid = 15 * exp(-(ttd - 8)² / 50)</code></li>
            <li><strong>Q.후면 청천 (최대 10점)</strong>: 비구름이 지나간 후 하늘이 개이는 '후면 청천' 현상이 감지되면 특별 보너스 점수를 부여합니다.<br><code>조건: 일몰 직전 저층운 20%p 이상 감소 & 중/상층운 20% 이상 존재 시 +10점</code></li>
        </ul>
        </div>`;
        }

        initializeBible();
        main();
    </script>
</body>
</html>