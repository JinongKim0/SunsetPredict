<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<link rel="icon" href="data:;base64,iVBORw0KGgo=">
<title>Sunset HDRI Scorecard — 하늘공원 & 선유교</title>
<style>
  :root{ --bg:#0e1016; --card:#161b23; --ink:#e9eef6; --muted:#a6b0c4; --accent:#3a7afe; }
  html,body{background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,Arial,sans-serif;margin:0;padding:0}
  header{padding:16px 14px;border-bottom:1px solid #232735;background:linear-gradient(180deg,rgba(58,122,254,0.08),transparent)}
  h1{font-size:19px;margin:0 0 4px}
  .sub{color:var(--muted);font-size:12.5px;margin:0}
  .wrap{max-width:880px;margin:0 auto;padding:12px}
  .grid{display:grid;grid-template-columns:1fr;gap:12px}
  .card{background:var(--card);border:1px solid #242a36;border-radius:12px;overflow:hidden}
  .card header{display:flex;align-items:center;justify-content:space-between;background:transparent;border:none;padding:12px 14px}
  .loc{display:flex;gap:8px;align-items:center}
  .badge{font-size:11.5px;border:1px solid #2b3140;border-radius:999px;padding:3px 8px;color:var(--muted)}
  .src{color:var(--muted);font-size:12px;margin-left:6px}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button{background:var(--accent);color:white;border:0;border-radius:10px;padding:8px 10px;font-size:12.5px;font-weight:700;cursor:pointer}
  button.ghost{background:transparent;border:1px solid #2b3140;color:#cfd7e6}
  .note{font-size:11.5px;color:var(--muted);padding:10px 14px;line-height:1.5}
  a{color:#9bb7ff;text-decoration:none}
  a:hover{text-decoration:underline}
  footer{color:#8d97aa;font-size:11.5px;padding:14px 14px 28px}
  .sp{opacity:.85}
  .err{color:#ffb1b1}
  .two-col{display:grid;grid-template-columns:1fr;gap:10px}
  @media(min-width:700px){.two-col{grid-template-columns:1fr 1fr}}
  .mini{font-size:11.5px}
  .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;background:#0c0f15;border:1px solid #2b3140;border-radius:6px;padding:2px 6px}

  /* 표 */
  table{width:100%;border-collapse:collapse}
  th,td{padding:8px 10px;border-top:1px solid #232735;font-size:12.5px;text-align:right;white-space:nowrap;vertical-align:top}
  th{color:#cbd3e1;text-align:center;background:#192131;position:sticky;top:0;z-index:1}
  td:first-child, th:first-child{text-align:left}
  .score{font-weight:700}
  .pill{padding:2px 7px;border-radius:999px;font-weight:700;font-size:11px;display:inline-block}
  .great{background:rgba(30,142,62,0.15);color:#8de6a6;border:1px solid rgba(30,142,62,0.35)}
  .good{background:rgba(58,122,254,0.12);color:#a8c3ff;border:1px solid rgba(58,122,254,0.35)}
  .fair{background:rgba(176,127,0,0.18);color:#ffd27a;border:1px solid rgba(176,127,0,0.35)}
  .poor{background:rgba(176,59,59,0.18);color:#ffb1b1;border:1px solid rgba(176,59,59,0.35)}

  /* 촬영 시간대 & 강수확률: 두 줄 고정 + 줄 내 개행 금지 */
  .sw{white-space:normal;line-height:1.3}
  .nowrap{white-space:nowrap}

  /* 모바일 간편 보기: 보조 컬럼 숨김 (기본 ON in small screens) */
  .col-optional{}
  body.compact .col-optional{display:none}

  /* 로딩 상태 */
  .skeleton{padding:16px;color:#9aa3b6}

  /* 헤더 툴팁 트리거 표시 */
  th.info{cursor:pointer;position:relative}
  th.info::after{content:"ⓘ";font-size:10px;margin-left:6px;color:#9bb7ff}

  /* 오버레이(모바일: 바텀시트, 데스크톱: 모달) */
  .overlay{position:fixed;inset:0;background:rgba(0,0,0,0.45);backdrop-filter:blur(2px);display:none;align-items:flex-end;justify-content:center;z-index:50}
  .overlay.show{display:flex}
  .sheet{background:var(--card);border:1px solid #242a36;border-radius:14px 14px 0 0;width:100%;max-height:75vh;overflow:auto;padding:12px 14px}
  .sheet h3{margin:4px 0 8px;font-size:14px}
  .sheet .mini{font-size:12px;line-height:1.55;color:#c8d0e0}
  .sheet .close{position:sticky;top:0;float:right;margin:-6px -4px 0 0;background:transparent;border:1px solid #2b3140;color:#cfd7e6;border-radius:8px;padding:4px 8px}
  @media(min-width:820px){
    .sheet{max-width:560px;border-radius:12px}
  }

  /* 더 작은 화면 최적화 */
  @media(max-width:430px){
    h1{font-size:18px}
    th,td{font-size:12px;padding:7px 8px}
    .wrap{padding:10px}
    .controls button{font-size:12px;padding:7px 9px}
  }
</style>
</head>
<body>
  <header>
    <h1>Sunset HDRI Scorecard — 하늘공원 & 선유교</h1>
    <p class="sub">일몰 전후(±1h) + <b>Sun Window</b> + <b>촬영 시간대</b> + <b>강수확률</b> · CSV(UTF‑8+BOM)</p>
  </header>

  <div class="wrap">
    <div class="controls" style="margin-bottom:10px">
      <button id="refresh">지금 예보 새로고침</button>
      <button id="dlcsv" class="ghost">CSV 저장</button>
      <button id="toggle" class="ghost">모바일 간편 보기</button>
      <span class="src">표준시대: <b>Asia/Seoul</b> · 예보일수: <b>5일</b></span>
    </div>

    <!-- 1) 스코어보드 -->
    <div class="grid" id="panels">
      <div class="card skeleton">예보 로딩 중…</div>
    </div>

    <!-- 2) 측정치 안내 (간단 설명 + 자세한 설명은 헤더 터치로 오버레이) -->
    <div class="card" style="margin-top:12px">
      <div class="note">
        <b>측정치 안내(간략)</b> – 각 컬럼 헤더를 <b>터치/클릭</b>하면 자세한 설명이 오버레이로 뜹니다.
        <div class="mini" style="margin-top:6px">
          High/Mid/Low: 구름층 비율 · PM2.5: 미세먼지 · 시정: 가시거리 · T–Td: 기온–이슬점 · Sun Window: 서쪽 비차단율 · Clearing: 전선 후 가장자리 신호
        </div>
      </div>
    </div>

    <!-- 3) 점수 규칙 -->
    <div class="card" style="margin-top:12px">
      <div class="note">
        <b>점수 규칙(100점 만점)</b>
        <ul style="margin:6px 0 0 16px;padding:0">
          <li>중·상층운 평균 30–70%: +40 (15–85%: +20)</li>
          <li>저층운 20–50%: −10 · &gt;50%: −25</li>
          <li>PM2.5 ≤ 15: +20 · 15–35: +5 · &gt;35: −15</li>
          <li>시정 ≥ 10 km: +15 (5–10 km: +5 · &lt;5 km: −10)</li>
          <li>T–Td ≥ 3 °C: +10 (≤ 2 °C: −10)</li>
          <li>Sun Window ≥ 70%: +10 · 50–70%: +0 · 30–50%: −10 · 15–30%: −20 · &lt;15%: −30</li>
          <li>Clearing(후면청천): +10</li>
        </ul>
      </div>
    </div>

    <footer>
      데이터: Open‑Meteo & CAMS · 좌표: 하늘공원 37.56764, 126.88571 · 선유교 37.54361, 126.90000.
    </footer>
  </div>

  <!-- 오버레이 -->
  <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="sheet">
      <button class="close" id="ov-close">닫기</button>
      <h3 id="ov-title">제목</h3>
      <div id="ov-body" class="mini">내용</div>
    </div>
  </div>

<script>
const TZ = "Asia/Seoul";
const TZ_OFFSET_HOURS = 9;
const FORECAST_DAYS = 5;
const AVG_WINDOW_H = 1;
const WEDGE_SPREAD_DEG = 24;
const WEDGE_RAYS = 3;
const WEDGE_RADII_KM = [20, 40, 60];
const SAMPLE_CONCURRENCY = 3;

// 순서 고정: 하늘공원 → 선유교
const LOCATIONS = [
  { name: "하늘공원", lat: 37.56764, lon: 126.88571, source: "월드컵공원(하늘공원) 좌표" },
  { name: "선유교",   lat: 37.54361, lon: 126.90000, source: "선유도–양화 보행교(중앙부 근방)" }
];

const HOURLY_FIELDS_MAIN = "cloudcover_high,cloudcover_mid,cloudcover_low,visibility,temperature_2m,dewpoint_2m,precipitation_probability";
const HOURLY_FIELDS_WEDGE = "cloudcover_mid,cloudcover_low";
const DAILY_FIELDS = "sunset";

const panels = document.getElementById('panels');
const diag = document.getElementById('diag');
const DOW_FORMATTER = new Intl.DateTimeFormat('ko-KR', { weekday: 'short', timeZone: 'Asia/Seoul' });

// Overlay helpers
const overlay = document.getElementById('overlay');
const ovTitle = document.getElementById('ov-title');
const ovBody = document.getElementById('ov-body');
const ovClose = document.getElementById('ov-close');
function showOverlay(title, html){
  ovTitle.textContent = title;
  ovBody.innerHTML = html;
  overlay.classList.add('show'); overlay.setAttribute('aria-hidden', 'false');
}
function hideOverlay(){ overlay.classList.remove('show'); overlay.setAttribute('aria-hidden', 'true'); }
overlay.addEventListener('click', (e)=>{ if(e.target===overlay) hideOverlay(); });
ovClose.addEventListener('click', hideOverlay);
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideOverlay(); });

const METRIC_INFO = {
  "High": "<b>High</b> — 상층운 비율(%)입니다. 노을빛을 <i>받는 캔버스</i>가 되며 20–70%가 이상적입니다.",
  "Mid": "<b>Mid</b> — 중층운 비율(%). 상층운과 함께 붉은 하이라이트를 받습니다.",
  "Low": "<b>Low</b> — 저층운 비율(%). <u>서쪽 차단</u>의 주 원인이므로 많을수록 불리합니다.",
  "PM25": "<b>PM2.5</b> — 미세먼지(µg/m³). 낮을수록 시정과 대비가 좋아지고 색이 또렷합니다.",
  "Vis": "<b>시정</b> — 수평 가시거리(km). 10 km 이상이면 맑은 편입니다.",
  "TTd": "<b>T–Td</b> — 기온–이슬점(°C). 0–2°C는 안개/박무/저층운 리스크, ≥3°C면 비교적 안전합니다.",
  "SunAz": "<b>SunAz</b> — 일몰 태양 방위각(서=270°). 웨지 표본의 방향 기준입니다.",
  "SunWin": "<b>Sun Window</b> — 일몰 방위 ±12°에서 <i>중·저층운 차단</i>을 보정해 산출한 <u>비차단율</u>(%). 높을수록 ‘빛길’이 열려 있습니다.",
  "Clearing": "<b>Clearing</b> — 일몰 3시간 전 대비 저층운 −20%p &amp; 중/상층운 ≥20% → 전선 후 가장자리(후면청천) 신호입니다."
};

function attachHeaderTooltips(tableEl){
  const map = {
    "High%":"High","Mid%":"Mid","Low%":"Low","PM2.5":"PM25",
    "시정(km)":"Vis","T–Td(°C)":"TTd","SunAz(°)":"SunAz","Sun Window(%)":"SunWin","Clearing":"Clearing"
  };
  tableEl.querySelectorAll('th').forEach(th=>{
    const key = map[th.textContent.trim()];
    if(key){
      th.classList.add('info');
      th.addEventListener('click', ()=>{
        const title = th.textContent.trim();
        showOverlay(title, METRIC_INFO[key] || "정보 없음");
      });
    }
  });
}

function verdict(score){
  if(score >= 70) return {text:"Great", cls:"great"};
  if(score >= 50) return {text:"Good", cls:"good"};
  if(score >= 30) return {text:"Fair", cls:"fair"};
  return {text:"Low", cls:"poor"};
}
function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
function fmt(n, digits=0){ return (n==null || isNaN(n)) ? "—" : Number(n).toFixed(digits); }
function toRad(d){ return d * Math.PI / 180; }
function toDeg(r){ return r * 180 / Math.PI; }

function dayOfYear(y, m, d){
  return Math.floor((Date.UTC(y, m-1, d) - Date.UTC(y, 0, 0)) / 86400000);
}
function solarParams(y, mo, d, hh, mm, lonDeg, tzHours){
  const N = dayOfYear(y, mo, d);
  const fracHour = hh + mm/60;
  const gamma = 2*Math.PI/365 * (N - 1 + (fracHour - 12)/24);
  const eqTime = 229.18 * (0.000075 + 0.001868*Math.cos(gamma) - 0.032077*Math.sin(gamma) - 0.014615*Math.cos(2*gamma) - 0.040849*Math.sin(2*gamma));
  const decl = 0.006918 - 0.399912*Math.cos(gamma) + 0.070257*Math.sin(gamma) - 0.006758*Math.cos(2*gamma) + 0.000907*Math.sin(2*gamma) - 0.002697*Math.cos(3*gamma) + 0.00148*Math.sin(3*gamma);
  const timeOffset = eqTime + 4*lonDeg - 60*tzHours;
  const tst = fracHour*60 + timeOffset;
  const haDeg = (tst/4) - 180;
  return {decl, ha: toRad(haDeg)};
}
function solarAzimuthDeg(localISO, latDeg, lonDeg, tzOffsetHours){
  const m = localISO.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})/);
  if(!m) return NaN;
  const y = +m[1], mo = +m[2], d = +m[3], hh = +m[4], mm = +m[5];
  const {decl, ha} = solarParams(y, mo, d, hh, mm, lonDeg, tzOffsetHours);
  const lat = toRad(latDeg);
  let az = Math.atan2(Math.sin(ha), Math.cos(ha)*Math.sin(lat) - Math.tan(decl)*Math.cos(lat));
  az = (toDeg(az) + 180) % 360;
  return az;
}
function solarAltitudeDeg(localISO, latDeg, lonDeg, tzOffsetHours){
  const m = localISO.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})/);
  if(!m) return NaN;
  const y = +m[1], mo = +m[2], d = +m[3], hh = +m[4], mm = +m[5];
  const {decl, ha} = solarParams(y, mo, d, hh, mm, lonDeg, tzOffsetHours);
  const lat = toRad(latDeg);
  const sinAlt = Math.sin(lat)*Math.sin(decl) + Math.cos(lat)*Math.cos(decl)*Math.cos(ha);
  return toDeg(Math.asin(sinAlt));
}
function destPoint(latDeg, lonDeg, distanceKm, bearingDeg){
  const R = 6371.0; const δ = distanceKm / R;
  const φ1 = toRad(latDeg), λ1 = toRad(lonDeg), θ = toRad(bearingDeg);
  const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
  const sinδ = Math.sin(δ), cosδ = Math.cos(δ);
  const sinφ2 = sinφ1*cosδ + cosφ1*sinδ*Math.cos(θ);
  const φ2 = Math.asin(sinφ2);
  const y = Math.sin(θ)*sinδ*cosφ1;
  const x = cosδ - sinφ1*sinφ2;
  const λ2 = λ1 + Math.atan2(y, x);
  return { lat: toDeg(φ2), lon: (toDeg(λ2)+540)%360 - 180 };
}

// KST helpers
function parseKST(localISO){ return new Date(localISO + "+09:00"); }
function toKSTLocalISO(date){
  const s = date.toLocaleString('sv-SE', { timeZone: 'Asia/Seoul', hour12: false });
  return s.replace(' ', 'T').slice(0, 16);
}
function kstAddMinutes(localISO, minutes){
  const d = parseKST(localISO);
  d.setMinutes(d.getMinutes() + minutes);
  return toKSTLocalISO(d);
}
function fmtTime24KST(localISO){
  const d = parseKST(localISO);
  return d.toLocaleTimeString('sv-SE', { timeZone: 'Asia/Seoul', hour: '2-digit', minute: '2-digit', hour12: false });
}
function fmtDateCompactWithDow(dateStr){
  // input 'YYYY-MM-DD' -> 'M.D (요일)'
  const d = new Date(dateStr + "T12:00:00+09:00");
  const m = d.getMonth()+1;
  const day = d.getDate();
  const dow = DOW_FORMATTER.format(d);
  return `${m}.${day} (${dow})`;
}

// Altitude crossing finder
function findAltitudeCrossing(lat, lon, targetAlt, tStartISO, tEndISO, stepMin){
  let t = tStartISO;
  let prevAlt = solarAltitudeDeg(t, lat, lon, TZ_OFFSET_HOURS);
  for(let m=stepMin; parseKST(t) < parseKST(tEndISO); m+=stepMin){
    const t2 = kstAddMinutes(t, stepMin);
    const alt2 = solarAltitudeDeg(t2, lat, lon, TZ_OFFSET_HOURS);
    if((prevAlt - targetAlt) * (alt2 - targetAlt) <= 0){
      const frac = (targetAlt - prevAlt) / ((alt2 - prevAlt) || 1e-6);
      const dt = stepMin * frac;
      return kstAddMinutes(t, dt);
    }
    t = t2;
    prevAlt = alt2;
  }
  return null;
}

function distWeight(km){ return Math.exp(-km/50); }
function indexNearSunset(hourlyTimesISO, sunsetISO){
  if(!sunsetISO) return null;
  const target = parseKST(sunsetISO).getTime();
  let bestIdx = 0, bestDiff = Infinity;
  for(let i=0;i<hourlyTimesISO.length;i++){
    const t = parseKST(hourlyTimesISO[i]).getTime();
    const d = Math.abs(t - target);
    if(d < bestDiff){ bestIdx = i; bestDiff = d; }
  }
  return bestIdx;
}
function hasClearing(lowArr, midArr, highArr, idx){
  if(idx==null || idx<3) return false;
  const lowNow = lowArr[idx]; const lowPrev = lowArr[idx-3];
  const midHighNow = Math.max(midArr[idx], highArr[idx]);
  return (lowPrev - lowNow >= 20) && (midHighNow >= 20);
}
function avgWindow(arr, idx, width){
  if(!arr || idx==null) return NaN;
  let s=0,c=0;
  for(let k=-width;k<=width;k++){
    const i = idx+k;
    if(i>=0 && i<arr.length && typeof arr[i]==='number'){ s+=arr[i]; c++; }
  }
  return c? (s/c): NaN;
}
function scoreOne(h, m, l, pm25, vis_m, t2m, td2m, clearing, sunWindowFrac){
  let s = 0;
  const midHighAvg = (h + m) / 2.0;
  if(midHighAvg >= 30 && midHighAvg <= 70) s += 40;
  else if(midHighAvg >= 15 && midHighAvg <= 85) s += 20;
  if(l > 50) s -= 25; else if(l > 20) s -= 10;
  if(pm25 <= 15) s += 20; else if(pm25 <= 35) s += 5; else s -= 15;
  const vis_km = vis_m / 1000.0;
  if(vis_km >= 10) s += 15; else if(vis_km >= 5) s += 5; else s -= 10;
  const ttd = t2m - td2m;
  if(ttd >= 3) s += 10; else if(ttd <= 2) s -= 10;
  if(sunWindowFrac >= 0.70) s += 10;
  else if(sunWindowFrac >= 0.50) s += 0;
  else if(sunWindowFrac >= 0.30) s -= 10;
  else if(sunWindowFrac >= 0.15) s -= 20;
  else s -= 30;
  if(clearing) s += 10;
  return {score:s, vis_km, ttd};
}

// fetch wrapper
async function fetchJsonOrThrow(url){
  const r = await fetch(url);
  if(!r.ok){
    const t = await r.text().catch(()=> "");
    throw new Error(`[${r.status}] ${url.pathname}${url.search}\n${t.slice(0,180)}`);
  }
  return r.json();
}
async function pMap(items, limit, mapper){
  const ret = new Array(items.length);
  let i=0;
  async function next(){
    if(i>=items.length) return;
    const cur = i++;
    try{ ret[cur]=await mapper(items[cur], cur); }
    catch(e){ ret[cur]={error:e}; }
    return next();
  }
  const tasks = [];
  for(let k=0;k<Math.min(limit, items.length);k++) tasks.push(next());
  await Promise.all(tasks);
  return ret;
}

function buildCard(loc){
  const el = document.createElement('div');
  el.className = 'card';
  el.innerHTML = `
    <header>
      <div class="loc"><div class="badge">좌표 ${loc.lat.toFixed(5)}, ${loc.lon.toFixed(5)}</div> <span class="src">${loc.name}</span></div>
      <div class="src">원본: ${loc.source}</div>
    </header>
    <div style="overflow:auto">
      <table>
        <thead>
          <tr>
            <th>날짜</th>
            <th>판정</th>
            <th class="score">점수</th>
            <th>촬영 시간대</th>
            <th>강수확률</th>
            <th class="col-optional">High%</th>
            <th class="col-optional">Mid%</th>
            <th class="col-optional">Low%</th>
            <th class="col-optional">PM2.5</th>
            <th class="col-optional">시정(km)</th>
            <th class="col-optional">T–Td(°C)</th>
            <th class="col-optional">SunAz(°)</th>
            <th class="col-optional">Sun&nbsp;Window(%)</th>
            <th class="col-optional">Clearing</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  `;
  panels.appendChild(el);
  // 헤더 툴팁 연결
  attachHeaderTooltips(el.querySelector('table'));
  return el.querySelector('tbody');
}

// 선택 구간과 겹치는 시간 버킷을 기준으로 최대 강수확률 집계
function maxProbBetweenHourly(timesISO, probs, startISO, endISO){
  if(!timesISO || !probs || !startISO || !endISO) return null;
  const t0 = parseKST(startISO).getTime();
  const t1 = parseKST(endISO).getTime();
  let mx = null;
  for(let i=0;i<timesISO.length;i++){
    const ti = parseKST(timesISO[i]).getTime();
    const te = (i+1 < timesISO.length) ? parseKST(timesISO[i+1]).getTime() : (ti + 3600000);
    const overlap = Math.min(te, t1) > Math.max(ti, t0);
    if(overlap){
      const v = probs[i];
      if(typeof v === 'number'){
        if(mx===null || v>mx) mx = v;
      }
    }
  }
  return mx;
}

async function fetchAndRender(){
  panels.innerHTML = '';
  const allRows = [];

  for(const loc of LOCATIONS){
    const tbody = buildCard(loc);

    const urlWx = new URL('https://api.open-meteo.com/v1/forecast');
    urlWx.searchParams.set('latitude', loc.lat);
    urlWx.searchParams.set('longitude', loc.lon);
    urlWx.searchParams.set('hourly', HOURLY_FIELDS_MAIN);
    urlWx.searchParams.set('daily', DAILY_FIELDS);
    urlWx.searchParams.set('timezone', TZ);
    urlWx.searchParams.set('forecast_days', FORECAST_DAYS);

    const urlAQ = new URL('https://air-quality-api.open-meteo.com/v1/air-quality');
    urlAQ.searchParams.set('latitude', loc.lat);
    urlAQ.searchParams.set('longitude', loc.lon);
    urlAQ.searchParams.set('hourly', 'pm2_5');
    urlAQ.searchParams.set('timezone', TZ);
    urlAQ.searchParams.set('forecast_days', FORECAST_DAYS);

    let wx, aq;
    try{
      [wx, aq] = await Promise.all([fetchJsonOrThrow(urlWx), fetchJsonOrThrow(urlAQ)]);
    }catch(e){
      panels.innerHTML = '<div class="card"><div class="note err"><b>데이터 로드 중 오류</b>: '+(e.message||e)+'</div></div>';
      return;
    }

    const H = wx.hourly, D = wx.daily, AQ = aq.hourly;
    const hourlyTimes = H.time;
    const dailyTimes = D.time;
    const sunsetTimes = D.sunset;

    for(let d=0; d<dailyTimes.length; d++){
      const sunsetISO = sunsetTimes ? sunsetTimes[d] : null;
      const idx = indexNearSunset(hourlyTimes, sunsetISO);
      let useIdx = idx;
      if(useIdx == null){
        const fallbackISO = dailyTimes[d] + "T18:30";
        useIdx = indexNearSunset(hourlyTimes, fallbackISO);
      }

      const h = avgWindow(H.cloudcover_high, useIdx, AVG_WINDOW_H);
      const m = avgWindow(H.cloudcover_mid, useIdx, AVG_WINDOW_H);
      const l = avgWindow(H.cloudcover_low, useIdx, AVG_WINDOW_H);
      const pm = avgWindow(AQ.pm2_5, useIdx, AVG_WINDOW_H);
      const vis = avgWindow(H.visibility, useIdx, AVG_WINDOW_H);
      const t2m = avgWindow(H.temperature_2m, useIdx, AVG_WINDOW_H);
      const td  = avgWindow(H.dewpoint_2m, useIdx, AVG_WINDOW_H);
      const clearing = hasClearing(H.cloudcover_low, H.cloudcover_mid, H.cloudcover_high, useIdx);

      let sunAz = 270;
      if(sunsetISO){
        const az = solarAzimuthDeg(sunsetISO, loc.lat, loc.lon, TZ_OFFSET_HOURS);
        if(!isNaN(az)){ sunAz = clamp(az, 200, 320); }
      }

      // 서쪽 차단 웨지 표본
      const half = WEDGE_SPREAD_DEG/2;
      const wedge = [];
      for(const R of WEDGE_RADII_KM){
        for(let i=0;i<WEDGE_RAYS;i++){
          const frac = (WEDGE_RAYS===1) ? 0.5 : i/(WEDGE_RAYS-1);
          const bearing = sunAz - half + frac*WEDGE_SPREAD_DEG;
          const dst = destPoint(loc.lat, loc.lon, R, bearing);
          wedge.push({R, bearing, lat: dst.lat, lon: dst.lon});
        }
      }
      const sampleResults = await pMap(wedge, SAMPLE_CONCURRENCY, async (s) => {
        const u = new URL('https://api.open-meteo.com/v1/forecast');
        u.searchParams.set('latitude', s.lat);
        u.searchParams.set('longitude', s.lon);
        u.searchParams.set('hourly', HOURLY_FIELDS_WEDGE);
        u.searchParams.set('timezone', TZ);
        u.searchParams.set('forecast_days', FORECAST_DAYS);
        try{
          const j = await fetchJsonOrThrow(u);
          const tArr = j.hourly.time;
          const idx2 = indexNearSunset(tArr, sunsetISO);
          const ii = (idx2!=null)? idx2 : 0;
          const midv = j.hourly.cloudcover_mid[ii];
          const lowv = j.hourly.cloudcover_low[ii];
          return {s, midv, lowv};
        }catch(e){
          return {s, error:true};
        }
      });

      let wsum = 0, osum = 0, okCount = 0;
      for(const r of sampleResults){
        if(!r || r.error) continue;
        const occ = clamp((0.6*r.midv + 0.4*r.lowv)/100, 0, 1);
        const w = distWeight(r.s.R);
        osum += occ * w;
        wsum += w;
        okCount++;
      }
      let sunWindow = 0.5;
      if(okCount > 0 && wsum > 0){
        const occAvg = osum/wsum;
        sunWindow = clamp(1 - occAvg, 0, 1);
      }

      const {score, vis_km, ttd} = scoreOne(h, m, l, pm, vis, t2m, td, clearing, sunWindow);
      const v = verdict(score);

      // 촬영 시간대 & 강수확률
      let goldenStart=null, goldenEnd=null, redStart=null, redEnd=null, shootHtml="—", shootPlain="—";
      let rainHtml="—", gProb=null, rProb=null;
      if(sunsetISO){
        const preStart = kstAddMinutes(sunsetISO, -180);
        const postEnd  = kstAddMinutes(sunsetISO,  120);
        goldenStart = findAltitudeCrossing(loc.lat, loc.lon, 6, preStart, sunsetISO, 2);
        const sunsetAt0 = sunsetISO;
        redEnd     = findAltitudeCrossing(loc.lat, loc.lon, -6, sunsetAt0, postEnd, 2);
        goldenEnd  = sunsetAt0;
        redStart   = sunsetAt0;
        if(!goldenStart){ goldenStart = kstAddMinutes(sunsetISO, -60); }
        if(!redEnd){ redEnd = kstAddMinutes(sunsetISO, 40); }
        const g = `골든 ${fmtTime24KST(goldenStart)} - ${fmtTime24KST(goldenEnd)}`;
        const r = `레드 ${fmtTime24KST(redStart)} - ${fmtTime24KST(redEnd)}`;
        shootHtml = `<span class="nowrap">${g}</span><br><span class="nowrap">${r}</span>`;
        shootPlain = `${g} / ${r}`;

        gProb = maxProbBetweenHourly(hourlyTimes, H.precipitation_probability, goldenStart, goldenEnd);
        rProb = maxProbBetweenHourly(hourlyTimes, H.precipitation_probability, redStart, redEnd);
        const gtxt = (gProb==null? "—" : `${Math.round(gProb)}%`);
        const rtxt = (rProb==null? "—" : `${Math.round(rProb)}%`);
        rainHtml = `<span class="nowrap">골든 ${gtxt}</span><br><span class="nowrap">레드 ${rtxt}</span>`;
      }

      const dateFmt = fmtDateCompactWithDow(dailyTimes[d]);

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${dateFmt}</td>
        <td><span class="pill ${v.cls}">${v.text}</span></td>
        <td class="score">${fmt(score)}</td>
        <td class="sw">${shootHtml}</td>
        <td class="sw">${rainHtml}</td>
        <td class="col-optional">${fmt(h)}</td>
        <td class="col-optional">${fmt(m)}</td>
        <td class="col-optional">${fmt(l)}</td>
        <td class="col-optional">${fmt(pm,1)}</td>
        <td class="col-optional">${fmt(vis_km,1)}</td>
        <td class="col-optional">${fmt(ttd,1)}</td>
        <td class="col-optional">${fmt(sunAz,0)}</td>
        <td class="col-optional">${fmt(sunWindow*100,0)}</td>
        <td class="col-optional">${clearing ? 'Yes' : '—'}</td>
      `;
      tbody.appendChild(tr);

      allRows.push({
        location: loc.name, date: dateFmt, verdict: v.text, score: fmt(score),
        shooting_window: shootPlain,
        precip_golden_max: (gProb==null? "" : Math.round(gProb)),
        precip_red_max: (rProb==null? "" : Math.round(rProb)),
        high:h, mid:m, low:l, pm25:pm,
        visibility_km: vis_km, T_minus_Td: ttd, sunAz: Math.round(sunAz),
        sunWindow_percent: Math.round(sunWindow*100), clearing: clearing ? 1 : 0
      });
    }
  }

  // CSV export
  const btn = document.getElementById('dlcsv');
  btn.onclick = () => {
    const header = ["location","date","verdict","score","shooting_window","precip_golden_max","precip_red_max","high","mid","low","pm25","visibility_km","T_minus_Td","sunAz","sunWindow_percent","clearing"];
    const esc = (v) => {
      if(v===undefined || v===null) return "";
      const s = String(v);
      return /[\",\r\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
    };
    const lines = [];
    lines.push("sep=,");
    lines.push(header.join(","));
    for(const r of allRows){
      lines.push(header.map(k => esc(r[k])).join(","));
    }
    const csvContent = "\uFEFF" + lines.join("\r\n");
    const blob = new Blob([csvContent], {type: "text/csv;charset=utf-8;"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "sunset_scorecard.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };
}

// 모바일: 작은 화면이면 기본적으로 compact 모드 ON
if (window.matchMedia("(max-width: 430px)").matches) {
  document.body.classList.add('compact');
}

document.getElementById('refresh').addEventListener('click', () => {
  panels.innerHTML = '<div class="card skeleton">예보 로딩 중…</div>';
  fetchAndRender().catch(err => {
    panels.innerHTML = '<div class="card"><div class="note err"><b>데이터 로드 중 오류</b>: '+(err.message||err)+'</div></div>';
  });
});
document.getElementById('toggle').addEventListener('click', () => {
  document.body.classList.toggle('compact');
});

// 최초 로드
fetchAndRender().catch(err => {
  panels.innerHTML = '<div class="card"><div class="note err"><b>데이터 로드 중 오류</b>: '+(err.message||err)+'</div></div>';
});
</script>
</body>
</html>