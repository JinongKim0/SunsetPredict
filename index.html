<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<link rel="icon" href="data:;base64,iVBORw0KGgo=">
<title>언제 노을이 예쁠까? v1.1 — 하늘공원 & 선유교</title>
<style>
  :root{ --bg:#0e1016; --card:#161b23; --ink:#e9eef6; --muted:#a6b0c4; --accent:#3a7afe; }
  html,body{background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,Arial,sans-serif;margin:0;padding:0}
  header{padding:16px 14px;border-bottom:1px solid #232735;background:linear-gradient(180deg,rgba(58,122,254,0.08),transparent)}
  h1{font-size:19px;margin:0 0 4px}
  .sub{color:var(--muted);font-size:12.5px;margin:0}
  .wrap{max-width:880px;margin:0 auto;padding:12px}
  .grid{display:grid;grid-template-columns:1fr;gap:12px}
  .card{background:var(--card);border:1px solid #242a36;border-radius:12px;overflow:hidden}
  .card header{display:flex;align-items:center;justify-content:space-between;background:transparent;border:none;padding:12px 14px}
  .loc{display:flex;gap:8px;align-items:center}
  .badge{font-size:11.5px;border:1px solid #2b3140;border-radius:999px;padding:3px 8px;color:var(--muted)}
  .src{color:var(--muted);font-size:12px;margin-left:6px}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button{background:var(--accent);color:white;border:0;border-radius:10px;padding:8px 10px;font-size:12.5px;font-weight:700;cursor:pointer}
  button.ghost{background:transparent;border:1px solid #2b3140;color:#cfd7e6}
  .note{font-size:11.5px;color:var(--muted);padding:10px 14px;line-height:1.5}
  a{color:#9bb7ff;text-decoration:none}
  a:hover{text-decoration:underline}
  footer{color:#8d97aa;font-size:11.5px;padding:14px 14px 28px}
  .sp{opacity:.85}
  .err{color:#ffb1b1}
  .two-col{display:grid;grid-template-columns:1fr;gap:10px}
  @media(min-width:700px){.two-col{grid-template-columns:1fr 1fr}}
  .mini{font-size:11.5px}
  .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;background:#0c0f15;border:1px solid #2b3140;border-radius:6px;padding:2px 6px}

  /* 표 */
  table{width:100%;border-collapse:collapse}
  th,td{padding:8px 10px;border-top:1px solid #232735;font-size:12.5px;text-align:right;white-space:nowrap;vertical-align:top}
  th{color:#cbd3e1;text-align:center;background:#192131;position:sticky;top:0;z-index:1}
  td:first-child, th:first-child{text-align:left}
  .score{font-weight:700}
  .pill{padding:2px 7px;border-radius:999px;font-weight:700;font-size:11px;display:inline-block}
  .great{background:rgba(30,142,62,0.15);color:#8de6a6;border:1px solid rgba(30,142,62,0.35)}
  .good{background:rgba(58,122,254,0.12);color:#a8c3ff;border:1px solid rgba(58,122,254,0.35)}
  .fair{background:rgba(176,127,0,0.18);color:#ffd27a;border:1px solid rgba(176,127,0,0.35)}
  .poor{background:rgba(176,59,59,0.18);color:#ffb1b1;border:1px solid rgba(176,59,59,0,35)}

  /* 촬영 시간대 & 강수확률: 두 줄 고정 + 줄 내 개행 금지 */
  .sw{white-space:normal;line-height:1.3}
  .nowrap{white-space:nowrap}

  /* 모바일 간편 보기: 보조 컬럼 숨김 (기본 ON in small screens) */
  .col-optional{}
  body.compact .col-optional{display:none}

  /* 로딩 상태 */
  .skeleton{padding:16px;color:#9aa3b6}

  /* 헤더 툴팁 트리거 표시 */
  th.info{cursor:pointer;position:relative}
  th.info::after{content:"ⓘ";font-size:10px;margin-left:6px;color:#9bb7ff}

  /* 오버레이(가운데 모달) */
  .overlay{position:fixed;inset:0;background:rgba(0,0,0,0.45);backdrop-filter:blur(2px);display:none;align-items:center;justify-content:center;z-index:50}
  .overlay.show{display:flex}
  .sheet{background:var(--card);border:1px solid #242a36;border-radius:12px;width:calc(100% - 24px);max-width:560px;max-height:80vh;overflow:auto;padding:12px 14px;box-shadow:0 10px 40px rgba(0,0,0,0.4)}
  .sheet h3{margin:4px 0 8px;font-size:14px}
  .sheet .mini{font-size:12px;line-height:1.55;color:#c8d0e0}
  .sheet .close{position:sticky;top:0;float:right;margin:-6px -4px 0 0;background:transparent;border:1px solid #2b3140;color:#cfd7e6;border-radius:8px;padding:4px 8px}

  @media(max-width:430px){
    h1{font-size:18px}
    th,td{font-size:12px;padding:7px 8px}
    .wrap{padding:10px}
    .controls button{font-size:12px;padding:7px 9px}
  }
</style>
<!-- SheetJS (XLSX) from CDN for true .xlsx export -->
<script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
</head>
<body>
  <header>
    <h1>언제 노을이 예쁠까? v1.1 — 하늘공원 & 선유교</h1>
    <p class="sub"><b>구간 평균</b> + <b>연속 점수</b> + <b>개선된 Sun Window</b> + <b>Clearing 판정 보강</b></p>
  </header>

  <div class="wrap">
    <div class="controls" style="margin-bottom:10px">
      <button id="refresh">지금 예보 새로고침</button>
      <button id="dlcsv" class="ghost">CSV 저장(UTF‑8)</button>
      <button id="dlsx" class="ghost">엑셀 저장(.xlsx)</button>
      <button id="toggle" class="ghost">모바일 간편 보기</button>
      <span class="src">표준시대: <b>Asia/Seoul</b> · 예보일수: <b>5일</b></span>
    </div>

    <!-- 1) 스코어보드 -->
    <div class="grid" id="panels">
      <div class="card skeleton">예보 로딩 중…</div>
    </div>

    <!-- 2) 측정치 안내(간략) -->
    <div class="card" style="margin-top:12px">
      <div class="note">
        <b>측정치 안내(간략)</b> – 컬럼 헤더를 <b>터치/클릭</b>하면 자세한 설명이 모달로 뜹니다. 본 버전(v1.1)은 모든 기상/대기질 지표를 <u>촬영 전체 구간(골든 시작→레드 종료)</u>의 <b>시간가중 평균</b>으로 산출합니다.
      </div>
    </div>

    <!-- 3) 점수 규칙 -->
    <div class="card" style="margin-top:12px">
      <div class="note">
        <b>점수 규칙(연속 함수 · 100점 만점)</b>
        <ul style="margin:6px 0 0 16px;padding:0">
          <li>중·상층운 평균: <i>50% 최적</i>, 20–80% 범위에서 삼각형 보상 → <b>0–40점</b> (50%에서 +40)</li>
          <li>저층운: 0–50%는 <b>0→−10</b> 선형, 50–100%는 <b>−10→−25</b> 추가 선형 페널티</li>
          <li>PM2.5: 0–15: <b>+20</b> → 15–35: <b>+20→+5</b> → 35–100: <b>+5→−15</b> (선형)</li>
          <li>시정(km): 0–5: <b>−10→+5</b> → 5–10: <b>+5→+15</b> → ≥10: <b>+15</b></li>
          <li>T–Td(°C): 0–3°C: <b>−10→+10</b> (선형), ≥3°C: <b>+10</b></li>
          <li>Sun Window(%) = 1 − P(차단): <b>−30 + 40×(구간 평균 비차단율)</b></li>
          <li>Clearing(후면청천): 일몰 <b>−4~−2h</b> 저층운 평균 대비 <b>−30~+30m</b> 주변 평균이 <b>≥20%p 감소</b> &amp; 중/상층운 ≥20% → <b>+10</b></li>
        </ul>
      </div>
    </div>

    <footer>
      데이터: Open‑Meteo & CAMS · 좌표: 하늘공원 37.56764, 126.88571 · 선유교 37.54361, 126.90000.
      <div class="mini" style="margin-top:6px;color:#a4aec1">
        v1.1 변경: <b>구간 평균화</b>, <b>연속 점수</b>, <b>Sun Window 확률 결합</b>, <b>Clearing 판정 보강</b>.
      </div>
    </footer>
  </div>

  <!-- 모달 오버레이 -->
  <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="sheet">
      <button class="close" id="ov-close">닫기</button>
      <h3 id="ov-title">제목</h3>
      <div id="ov-body" class="mini">내용</div>
    </div>
  </div>

<script>
// =====================
// 구성 상수
// =====================
const TZ = "Asia/Seoul";
const TZ_OFFSET_HOURS = 9;
const FORECAST_DAYS = 5;
const WEDGE_SPREAD_DEG = 24; // SunAz ±12°
const WEDGE_RAYS = 3;        // 각 반경에서 샘플링할 방위 개수
const WEDGE_RADII_KM = [20, 40, 60];
const SAMPLE_CONCURRENCY = 3;

const LOCATIONS = [
  { name: "하늘공원", lat: 37.56764, lon: 126.88571, source: "월드컵공원(하늘공원) 좌표" },
  { name: "선유교",   lat: 37.54361, lon: 126.90000, source: "선유도–양화 보행교(중앙부 근방)" }
];

const HOURLY_FIELDS_MAIN = "cloudcover_high,cloudcover_mid,cloudcover_low,visibility,temperature_2m,dewpoint_2m,precipitation_probability";
const HOURLY_FIELDS_WEDGE = "cloudcover_mid,cloudcover_low";
const DAILY_FIELDS = "sunset";

// =====================
// DOM 핸들러
// =====================
const panels = document.getElementById('panels');
const overlay = document.getElementById('overlay');
const ovTitle = document.getElementById('ov-title');
const ovBody = document.getElementById('ov-body');
const ovClose = document.getElementById('ov-close');

function showOverlay(title, html){ ovTitle.textContent = title; ovBody.innerHTML = html; overlay.classList.add('show'); overlay.setAttribute('aria-hidden', 'false'); }
function hideOverlay(){ overlay.classList.remove('show'); overlay.setAttribute('aria-hidden', 'true'); }
overlay.addEventListener('click', (e)=>{ if(e.target===overlay) hideOverlay(); });
ovClose.addEventListener('click', hideOverlay);
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideOverlay(); });

const METRIC_INFO = {
  "High%": "<b>High</b> — 상층운 비율(%)의 <u>촬영 구간 평균</u>입니다.",
  "Mid%": "<b>Mid</b> — 중층운 비율(%), <u>촬영 구간 평균</u>입니다.",
  "Low%": "<b>Low</b> — 저층운 비율(%), <u>촬영 구간 평균</u>. 서쪽 차단에 가장 민감합니다.",
  "PM2.5": "<b>PM2.5</b> — 미세먼지(µg/m³) <u>촬영 구간 평균</u>. 낮을수록 대비/색 재현이 좋습니다.",
  "시정(km)": "<b>시정</b> — 수평 가시거리(km) <u>촬영 구간 평균</u>입니다.",
  "T–Td(°C)": "<b>T–Td</b> — 기온–이슬점(°C) <u>촬영 구간 평균</u>. 0–2°C는 박무/저층운 리스크, ≥3°C 안전권.",
  "SunAz(°)": "<b>SunAz</b> — 일몰 시 태양 방위각(서=270°)입니다. Sun Window 샘플링의 기준 방향입니다.",
  "Sun Window(%)": "<b>Sun Window</b> — 일몰 방위 ±12° 扇形에서 중·저층운의 <u>구간 평균 차단 확률</u>을 결합(\nP(차단)=1−(1−Mid)^0.6×(1−Low)^0.4\n)하여 산출한 <u>비차단율</u>(%). 높을수록 ‘빛길’이 열려 있습니다.",
  "Clearing": "<b>Clearing</b> — 일몰 4~2시간 전 대비 일몰 ±30분 동안 저층운이 ≥20%p 감소하고 동시에 중/상층운이 ≥20%이면 전선 후 가장자리(후면청천) 신호로 판단합니다."
};

function attachHeaderTooltips(tableEl){
  tableEl.querySelectorAll('th').forEach(th=>{
    const key = th.innerText.trim();
    if(METRIC_INFO[key]){
      th.classList.add('info');
      th.addEventListener('click', ()=> showOverlay(key, METRIC_INFO[key]));
    }
  });
}

// =====================
// 수학 유틸
// =====================
function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
function fmt(n, digits=0){ return (n==null || isNaN(n)) ? "—" : Number(n).toFixed(digits); }
function toRad(d){ return d * Math.PI / 180; }
function toDeg(r){ return r * 180 / Math.PI; }

function dayOfYear(y, m, d){ return Math.floor((Date.UTC(y, m-1, d) - Date.UTC(y, 0, 0)) / 86400000); }
function solarParams(y, mo, d, hh, mm, lonDeg, tzHours){
  const N = dayOfYear(y, mo, d);
  const fracHour = hh + mm/60;
  const gamma = 2*Math.PI/365 * (N - 1 + (fracHour - 12)/24);
  const eqTime = 229.18 * (0.000075 + 0.001868*Math.cos(gamma) - 0.032077*Math.sin(gamma) - 0.014615*Math.cos(2*gamma) - 0.040849*Math.sin(2*gamma));
  const decl = 0.006918 - 0.399912*Math.cos(gamma) + 0.070257*Math.sin(gamma) - 0.006758*Math.cos(2*gamma) + 0.000907*Math.sin(2*gamma) - 0.002697*Math.cos(3*gamma) + 0.00148*Math.sin(3*gamma);
  const timeOffset = eqTime + 4*lonDeg - 60*tzHours;
  const tst = fracHour*60 + timeOffset;
  const haDeg = (tst/4) - 180;
  return {decl, ha: toRad(haDeg)};
}
function solarAzimuthDeg(localISO, latDeg, lonDeg, tzOffsetHours){
  const m = localISO.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})/);
  if(!m) return NaN;
  const y = +m[1], mo = +m[2], d = +m[3], hh = +m[4], mm = +m[5];
  const {decl, ha} = solarParams(y, mo, d, hh, mm, lonDeg, tzOffsetHours);
  const lat = toRad(latDeg);
  let az = Math.atan2(Math.sin(ha), Math.cos(ha)*Math.sin(lat) - Math.tan(decl)*Math.cos(lat));
  az = (toDeg(az) + 180) % 360;
  return az;
}
function solarAltitudeDeg(localISO, latDeg, lonDeg, tzOffsetHours){
  const m = localISO.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})/);
  if(!m) return NaN;
  const y = +m[1], mo = +m[2], d = +m[3], hh = +m[4], mm = +m[5];
  const {decl, ha} = solarParams(y, mo, d, hh, mm, lonDeg, tzOffsetHours);
  const lat = toRad(latDeg);
  const sinAlt = Math.sin(lat)*Math.sin(decl) + Math.cos(lat)*Math.cos(decl)*Math.cos(ha);
  return toDeg(Math.asin(sinAlt));
}
function destPoint(latDeg, lonDeg, distanceKm, bearingDeg){
  const R = 6371.0; const δ = distanceKm / R;
  const φ1 = toRad(latDeg), λ1 = toRad(lonDeg), θ = toRad(bearingDeg);
  const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
  const sinδ = Math.sin(δ), cosδ = Math.cos(δ);
  const sinφ2 = sinφ1*cosδ + cosφ1*sinδ*Math.cos(θ);
  const φ2 = Math.asin(sinφ2);
  const y = Math.sin(θ)*sinδ*cosφ1;
  const x = cosδ - sinφ1*sinφ2;
  const λ2 = λ1 + Math.atan2(y, x);
  return { lat: toDeg(φ2), lon: (toDeg(λ2)+540)%360 - 180 };
}

// =====================
// 시간 & 타임존 유틸(KST)
// =====================
function parseKST(localISO){ return new Date(localISO + "+09:00"); }
function toKSTLocalISO(date){ const s = date.toLocaleString('sv-SE', { timeZone: 'Asia/Seoul', hour12: false }); return s.replace(' ', 'T').slice(0, 16); }
function kstAddMinutes(localISO, minutes){ const d = parseKST(localISO); d.setMinutes(d.getMinutes() + minutes); return toKSTLocalISO(d); }
function fmtTime24KST(localISO){ const d = parseKST(localISO); return d.toLocaleTimeString('sv-SE', { timeZone: 'Asia/Seoul', hour: '2-digit', minute: '2-digit', hour12: false }); }
function fmtDateCompactWithDow(dateStr){ const d = new Date(dateStr + "T12:00:00+09:00"); const m = d.getMonth()+1; const day = d.getDate(); const dow = d.toLocaleDateString('ko-KR', { weekday: 'short', timeZone: 'Asia/Seoul' }); return `${m}.${day} (${dow})`; }

// Altitude crossing finder
function findAltitudeCrossing(lat, lon, targetAlt, tStartISO, tEndISO, stepMin){
  let t = tStartISO;
  let prevAlt = solarAltitudeDeg(t, lat, lon, TZ_OFFSET_HOURS);
  for(let m=stepMin; parseKST(t) < parseKST(tEndISO); m+=stepMin){
    const t2 = kstAddMinutes(t, stepMin);
    const alt2 = solarAltitudeDeg(t2, lat, lon, TZ_OFFSET_HOURS);
    if((prevAlt - targetAlt) * (alt2 - targetAlt) <= 0){
      const frac = (targetAlt - prevAlt) / ((alt2 - prevAlt) || 1e-6);
      const dt = stepMin * frac;
      return kstAddMinutes(t, dt);
    }
    t = t2; prevAlt = alt2;
  }
  return null;
}

// 가중 평균(시간 겹침 비율)
function avgOverWindow(timesISO, values, startISO, endISO){
  if(!timesISO || !values || !startISO || !endISO) return NaN;
  const t0 = parseKST(startISO).getTime();
  const t1 = parseKST(endISO).getTime();
  if(!(t1 > t0)) return NaN;
  let s=0, w=0;
  for(let i=0;i<timesISO.length;i++){
    const a = parseKST(timesISO[i]).getTime();
    const b = (i+1<timesISO.length) ? parseKST(timesISO[i+1]).getTime() : a+3600000; // 1h
    const overlap = Math.max(0, Math.min(b,t1) - Math.max(a,t0));
    if(overlap>0){
      const v = values[i];
      if(typeof v === 'number' && !isNaN(v)){
        s += v * overlap; w += overlap;
      }
    }
  }
  return w ? s/w : NaN;
}

function distWeight(km){ return Math.exp(-km/50); }

// 가장 가까운 시간 인덱스(여전히 일부 용도에서 사용)
function indexNearSunset(hourlyTimesISO, sunsetISO){
  if(!sunsetISO) return null;
  const target = parseKST(sunsetISO).getTime();
  let bestIdx = 0, bestDiff = Infinity;
  for(let i=0;i<hourlyTimesISO.length;i++){
    const t = parseKST(hourlyTimesISO[i]).getTime();
    const d = Math.abs(t - target);
    if(d < bestDiff){ bestIdx = i; bestDiff = d; }
  }
  return bestIdx;
}

// Clearing(후면청천) 판정(구간 평균 기반)
function computeClearing(H, sunsetISO){
  const prevStart = kstAddMinutes(sunsetISO, -240); // -4h
  const prevEnd   = kstAddMinutes(sunsetISO, -120); // -2h
  const nowStart  = kstAddMinutes(sunsetISO, -30);  // -0.5h
  const nowEnd    = kstAddMinutes(sunsetISO,  30);  // +0.5h
  const lowPrev = avgOverWindow(H.time, H.cloudcover_low, prevStart, prevEnd);
  const lowNow  = avgOverWindow(H.time, H.cloudcover_low, nowStart, nowEnd);
  const midNow  = avgOverWindow(H.time, H.cloudcover_mid, nowStart, nowEnd);
  const highNow = avgOverWindow(H.time, H.cloudcover_high, nowStart, nowEnd);
  if([lowPrev, lowNow, midNow, highNow].some(v=>isNaN(v))) return false;
  const drop = lowPrev - lowNow; // %p
  const midHighNow = Math.max(midNow, highNow);
  return (drop >= 20) && (midHighNow >= 20);
}

// =====================
// 점수(연속 함수)
// =====================
function scoreCloudMidHigh(mid, high){
  const mh = (mid + high) / 2; // %
  // 50%에서 최대(+40), 20~80% 범위에서 선형으로 0까지 감소
  const delta = Math.abs(mh - 50);
  const norm = clamp(1 - delta/30, 0, 1); // 20↔80 사이에서 0~1
  return 40 * norm;
}
function scoreLowPenalty(low){
  // 0~50: 0→−10, 50~100: −10→−25
  if(low <= 50) return -10 * (low/50);
  const extra = (low-50)/50; // 0~1
  return -10 - 15*extra; // -10 ~ -25
}
function scorePM25(pm){
  if(pm <= 15) return 20 * (1 - pm/15) + 0; // 사실상 +20에 가깝게, 아래와 연속성 유지 위해 재정의
  if(pm <= 35){
    const t = (pm-15)/20; // 0~1
    return 20 + (5-20)*t; // +20 → +5
  }
  // 35~100: +5 → -15
  const t = clamp((pm-35)/(100-35), 0, 1);
  return 5 + (-15-5)*t;
}
function scoreVisibilityKm(vis_km){
  if(vis_km <= 5){
    const t = clamp(vis_km/5, 0, 1); // 0→5km
    return -10 + (5 - (-10))*t; // -10 → +5
  }
  if(vis_km <= 10){
    const t = (vis_km-5)/5; // 0→1
    return 5 + (15-5)*t; // +5 → +15
  }
  return 15;
}
function scoreTTD(ttd){
  if(ttd <= 0) return -10; // 매우 습함
  if(ttd >= 3) return 10;
  const t = ttd/3; // 0→1
  return -10 + (10 - (-10))*t; // -10 → +10 선형
}
function scoreSunWindow(frac){ // 0~1 (비차단율)
  return -30 + 40 * clamp(frac, 0, 1);
}

function verdict(score){
  if(score >= 70) return {text:"Great", cls:"great"};
  if(score >= 50) return {text:"Good", cls:"good"};
  if(score >= 30) return {text:"Fair", cls:"fair"};
  return {text:"Low", cls:"poor"};
}

function toContribRowObj(v){ const o={}; Object.keys(v).forEach(k=>o[`s_${k}`]=Math.round(v[k])); return o; }

// =====================
// 데이터 패치 헬퍼
// =====================
async function fetchJsonOrThrow(url){
  const r = await fetch(url);
  if(!r.ok){ const t = await r.text().catch(()=>""); throw new Error(`[${r.status}] ${url.pathname||url} ${t.slice(0,180)}`); }
  return r.json();
}
async function pMap(items, limit, mapper){
  const ret = new Array(items.length);
  let i=0;
  async function next(){
    if(i>=items.length) return;
    const cur = i++;
    try{ ret[cur]=await mapper(items[cur], cur); }
    catch(e){ ret[cur]={error:e}; }
    return next();
  }
  const tasks = [];
  for(let k=0;k<Math.min(limit, items.length);k++) tasks.push(next());
  await Promise.all(tasks);
  return ret;
}

// =====================
// UI 빌드
// =====================
function buildCard(loc){
  const el = document.createElement('div');
  el.className = 'card';
  el.innerHTML = `
    <header>
      <div class="loc"><div class="badge">좌표 ${loc.lat.toFixed(5)}, ${loc.lon.toFixed(5)}</div> <span class="src">${loc.name}</span></div>
      <div class="src">원본: ${loc.source}</div>
    </header>
    <div style="overflow:auto">
      <table>
        <thead>
          <tr>
            <th>날짜</th>
            <th>판정</th>
            <th class="score">점수</th>
            <th>촬영 시간대</th>
            <th>강수확률</th>
            <th class="col-optional">High%</th>
            <th class="col-optional">Mid%</th>
            <th class="col-optional">Low%</th>
            <th class="col-optional">PM2.5</th>
            <th class="col-optional">시정(km)</th>
            <th class="col-optional">T–Td(°C)</th>
            <th class="col-optional">SunAz(°)</th>
            <th class="col-optional">Sun&nbsp;Window(%)</th>
            <th class="col-optional">Clearing</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  `;
  panels.appendChild(el);
  attachHeaderTooltips(el.querySelector('table'));
  return el.querySelector('tbody');
}

function maxProbBetweenHourly(timesISO, probs, startISO, endISO){
  if(!timesISO || !probs || !startISO || !endISO) return null;
  const t0 = parseKST(startISO).getTime();
  const t1 = parseKST(endISO).getTime();
  let mx = null;
  for(let i=0;i<timesISO.length;i++){
    const ti = parseKST(timesISO[i]).getTime();
    const te = (i+1 < timesISO.length) ? parseKST(timesISO[i+1]).getTime() : (ti + 3600000);
    const overlap = Math.min(te, t1) > Math.max(ti, t0);
    if(overlap){ const v = probs[i]; if(typeof v === 'number'){ if(mx===null || v>mx) mx = v; } }
  }
  return mx;
}

// =====================
// 메인: fetch & render
// =====================
async function fetchAndRender(){
  panels.innerHTML = '';
  window.__ALL_ROWS__ = []; // for exports

  for(const loc of LOCATIONS){
    const tbody = buildCard(loc);

    const urlWx = new URL('https://api.open-meteo.com/v1/forecast');
    urlWx.searchParams.set('latitude', loc.lat);
    urlWx.searchParams.set('longitude', loc.lon);
    urlWx.searchParams.set('hourly', HOURLY_FIELDS_MAIN);
    urlWx.searchParams.set('daily', DAILY_FIELDS);
    urlWx.searchParams.set('timezone', TZ);
    urlWx.searchParams.set('forecast_days', FORECAST_DAYS);

    const urlAQ = new URL('https://air-quality-api.open-meteo.com/v1/air-quality');
    urlAQ.searchParams.set('latitude', loc.lat);
    urlAQ.searchParams.set('longitude', loc.lon);
    urlAQ.searchParams.set('hourly', 'pm2_5');
    urlAQ.searchParams.set('timezone', TZ);
    urlAQ.searchParams.set('forecast_days', FORECAST_DAYS);

    let wx, aq;
    try{ [wx, aq] = await Promise.all([fetchJsonOrThrow(urlWx), fetchJsonOrThrow(urlAQ)]); }
    catch(e){ panels.innerHTML = '<div class="card"><div class="note err"><b>데이터 로드 중 오류</b>: '+(e.message||e)+'</div></div>'; return; }

    const H = wx.hourly, D = wx.daily, AQ = aq.hourly;
    const hourlyTimes = H.time;
    const dailyTimes = D.time;
    const sunsetTimes = D.sunset;

    for(let d=0; d<dailyTimes.length; d++){
      const sunsetISO = sunsetTimes ? sunsetTimes[d] : null;
      // 촬영 구간(골든/레드) 계산
      let goldenStart=null, goldenEnd=null, redStart=null, redEnd=null;
      if(sunsetISO){
        const preStart = kstAddMinutes(sunsetISO, -180);
        const postEnd  = kstAddMinutes(sunsetISO,  120);
        goldenStart = findAltitudeCrossing(loc.lat, loc.lon, 6,   preStart, sunsetISO, 2) || kstAddMinutes(sunsetISO, -60);
        goldenEnd   = sunsetISO;
        redStart    = sunsetISO;
        redEnd      = findAltitudeCrossing(loc.lat, loc.lon, -6,  sunsetISO, postEnd, 2) || kstAddMinutes(sunsetISO, 40);
      }

      // 창~붉은 전체 구간(없으면 보수적 대체)
      const winStart = goldenStart || (dailyTimes[d] + "T17:30");
      const winEnd   = redEnd      || (dailyTimes[d] + "T19:10");

      // SunAz(일몰 기준 방위)
      let sunAz = 270;
      if(sunsetISO){ const az = solarAzimuthDeg(sunsetISO, loc.lat, loc.lon, TZ_OFFSET_HOURS); if(!isNaN(az)) sunAz = clamp(az, 200, 320); }

      // 메인 지표: 촬영 구간 평균
      const h = avgOverWindow(hourlyTimes, H.cloudcover_high, winStart, winEnd);
      const m = avgOverWindow(hourlyTimes, H.cloudcover_mid,  winStart, winEnd);
      const l = avgOverWindow(hourlyTimes, H.cloudcover_low,  winStart, winEnd);
      const pm= avgOverWindow(AQ.time,        AQ.pm2_5,      winStart, winEnd);
      const vis=avgOverWindow(hourlyTimes, H.visibility,     winStart, winEnd);
      const t2m=avgOverWindow(hourlyTimes, H.temperature_2m, winStart, winEnd);
      const td =avgOverWindow(hourlyTimes, H.dewpoint_2m,    winStart, winEnd);

      // Clearing 판정(보강)
      const clearing = sunsetISO ? computeClearing(H, sunsetISO) : false;

      // Sun Window: 扇形 표본(구간 평균) → 확률 결합
      const half = WEDGE_SPREAD_DEG/2;
      const wedge = [];
      for(const R of WEDGE_RADII_KM){
        for(let i=0;i<WEDGE_RAYS;i++){
          const frac = (WEDGE_RAYS===1) ? 0.5 : i/(WEDGE_RAYS-1);
          const bearing = sunAz - half + frac*WEDGE_SPREAD_DEG;
          const dst = destPoint(loc.lat, loc.lon, R, bearing);
          wedge.push({R, bearing, lat: dst.lat, lon: dst.lon});
        }
      }

      const sampleResults = await pMap(wedge, SAMPLE_CONCURRENCY, async (s) => {
        const u = new URL('https://api.open-meteo.com/v1/forecast');
        u.searchParams.set('latitude', s.lat);
        u.searchParams.set('longitude', s.lon);
        u.searchParams.set('hourly', HOURLY_FIELDS_WEDGE);
        u.searchParams.set('timezone', TZ);
        u.searchParams.set('forecast_days', FORECAST_DAYS);
        try{
          const j = await fetchJsonOrThrow(u);
          const tArr = j.hourly.time;
          const midAvg = avgOverWindow(tArr, j.hourly.cloudcover_mid, winStart, winEnd);
          const lowAvg = avgOverWindow(tArr, j.hourly.cloudcover_low, winStart, winEnd);
          return {s, midAvg, lowAvg};
        }catch(e){ return {s, error:true}; }
      });

      let wsum = 0, osum = 0, okCount = 0;
      for(const r of sampleResults){
        if(!r || r.error) continue;
        const midf = clamp((r.midAvg||0)/100, 0, 1);
        const lowf = clamp((r.lowAvg||0)/100, 0, 1);
        // 확률 결합: P(차단) = 1 - (1 - mid)^0.6 * (1 - low)^0.4
        const occ = 1 - Math.pow(1-midf, 0.6) * Math.pow(1-lowf, 0.4);
        const w = distWeight(r.s.R);
        osum += occ * w; wsum += w; okCount++;
      }
      let sunWindowFrac = 0.5;
      if(okCount > 0 && wsum > 0){
        const occAvg = osum/wsum; // 0~1
        sunWindowFrac = clamp(1 - occAvg, 0, 1);
      }

      // 점수(연속 함수) 계산
      const vis_km = (vis || 0)/1000;
      const ttd = (t2m - td);
      const contrib = {
        cloud: scoreCloudMidHigh(m, h),
        low:   scoreLowPenalty(l),
        pm:    scorePM25(pm),
        vis:   scoreVisibilityKm(vis_km),
        ttd:   scoreTTD(ttd),
        sunwin:scoreSunWindow(sunWindowFrac),
        clearing: clearing ? 10 : 0
      };
      const totalScore = Object.values(contrib).reduce((a,b)=>a+(isFinite(b)?b:0), 0);
      const v = verdict(totalScore);

      // 촬영 시간대 & 강수확률 표시(그룹 최대)
      let shootHtml="—", shootPlain="—", rainHtml="—", gProb=null, rProb=null;
      if(sunsetISO){
        const g = `골든 ${fmtTime24KST(goldenStart)} - ${fmtTime24KST(goldenEnd)}`;
        const r = `레드 ${fmtTime24KST(redStart)} - ${fmtTime24KST(redEnd)}`;
        shootHtml = `<span class="nowrap">${g}</span><br><span class="nowrap">${r}</span>`;
        shootPlain = `${g} / ${r}`;
        gProb = maxProbBetweenHourly(hourlyTimes, H.precipitation_probability, goldenStart, goldenEnd);
        rProb = maxProbBetweenHourly(hourlyTimes, H.precipitation_probability, redStart, redEnd);
        const gtxt = (gProb==null? "—" : `${Math.round(gProb)}%`);
        const rtxt = (rProb==null? "—" : `${Math.round(rProb)}%`);
        rainHtml = `<span class="nowrap">골든 ${gtxt}</span><br><span class="nowrap">레드 ${rtxt}</span>`;
      }

      const dateFmt = fmtDateCompactWithDow(dailyTimes[d]);

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${dateFmt}</td>
        <td><span class="pill ${v.cls}">${v.text}</span></td>
        <td class="score">${fmt(totalScore)}</td>
        <td class="sw">${shootHtml}</td>
        <td class="sw">${rainHtml}</td>
        <td class="col-optional">${fmt(h)}</td>
        <td class="col-optional">${fmt(m)}</td>
        <td class="col-optional">${fmt(l)}</td>
        <td class="col-optional">${fmt(pm,1)}</td>
        <td class="col-optional">${fmt(vis_km,1)}</td>
        <td class="col-optional">${fmt(ttd,1)}</td>
        <td class="col-optional">${fmt(sunAz,0)}</td>
        <td class="col-optional">${fmt(sunWindowFrac*100,0)}</td>
        <td class="col-optional">${clearing ? 'Yes' : '—'}</td>
      `;
      tbody.appendChild(tr);

      // 내보내기용 레코드(+기여도)
      window.__ALL_ROWS__.push({
        location: loc.name, date: dateFmt, verdict: v.text, score: Number(fmt(totalScore)),
        shooting_window: shootPlain,
        precip_golden_max: (gProb==null? "" : Math.round(gProb)),
        precip_red_max: (rProb==null? "" : Math.round(rProb)),
        high: Number(fmt(h)), mid: Number(fmt(m)), low: Number(fmt(l)),
        pm25: Number(fmt(pm,1)), visibility_km: Number(fmt(vis_km,1)), T_minus_Td: Number(fmt(ttd,1)),
        sunAz: Math.round(sunAz), sunWindow_percent: Math.round(sunWindowFrac*100), clearing: (clearing ? 1 : 0),
        ...toContribRowObj(contrib)
      });
    }
  }

  // CSV (UTF‑8 BOM)
  const header = [
    "location","date","verdict","score","shooting_window","precip_golden_max","precip_red_max","high","mid","low","pm25","visibility_km","T_minus_Td","sunAz","sunWindow_percent","clearing",
    "s_cloud","s_low","s_pm","s_vis","s_ttd","s_sunwin","s_clearing"
  ];
  const escCSV = (v) => {
    if(v===undefined || v===null) return "";
    const s = String(v);
    return /[\",\r\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
  };
  document.getElementById('dlcsv').onclick = () => {
    const rows = window.__ALL_ROWS__ || [];
    const lines = [];
    lines.push("sep=,"); lines.push(header.join(","));
    for(const r of rows){ lines.push(header.map(k => escCSV(r[k])).join(",")); }
    const csvContent = "\uFEFF" + lines.join("\r\n");
    const blob = new Blob([csvContent], {type: "text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = "sunset_scorecard.csv"; a.click();
    URL.revokeObjectURL(url);
  };

  // XLSX (true OOXML via SheetJS)
  document.getElementById('dlsx').onclick = () => {
    if(typeof XLSX === 'undefined' || !XLSX.utils){
      showOverlay("내보내기 오류", "<div class='mini'>네트워크 환경에서 라이브러리 로드에 실패했습니다. 페이지를 새로고침하거나 네트워크를 확인해 주세요.</div>");
      return;
    }
    const rows = window.__ALL_ROWS__ || [];
    const aoa = [header];
    for(const r of rows){ aoa.push(header.map(k => r[k])); }
    const ws = XLSX.utils.aoa_to_sheet(aoa);
    // Basic column widths for readability
    const wscols = [
      {wch: 8},  // location
      {wch: 10}, // date
      {wch: 8},  // verdict
      {wch: 6},  // score
      {wch: 26}, // shooting_window
      {wch: 10}, // precip_golden_max
      {wch: 10}, // precip_red_max
      {wch: 6}, {wch: 6}, {wch: 6}, // high/mid/low
      {wch: 8},  {wch: 10}, {wch: 8}, // pm/vis/ttd
      {wch: 6},  {wch: 10}, {wch: 8}, // sunAz/sunWindow/clearing
      {wch: 8},{wch: 8},{wch: 8},{wch: 8},{wch: 8},{wch: 10},{wch: 10} // contribs
    ];
    ws['!cols'] = wscols;
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Scorecard");
    XLSX.writeFile(wb, "sunset_scorecard.xlsx", {bookType: "xlsx"});
  };
}

// 모바일 기본 compact
if (window.matchMedia("(max-width: 430px)").matches) { document.body.classList.add('compact'); }

document.getElementById('refresh').addEventListener('click', () => {
  panels.innerHTML = '<div class="card skeleton">예보 로딩 중…</div>';
  fetchAndRender().catch(err => { panels.innerHTML = '<div class="card"><div class="note err"><b>데이터 로드 중 오류</b>: '+(err.message||err)+'</div></div>'; });
});
document.getElementById('toggle').addEventListener('click', () => { document.body.classList.toggle('compact'); });

// 초기 로드
fetchAndRender().catch(err => { panels.innerHTML = '<div class="card"><div class="note err"><b>데이터 로드 중 오류</b>: '+(err.message||err)+'</div></div>'; });
</script>
</body>
</html>
